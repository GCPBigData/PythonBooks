<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 10 (filtered)">
<title> </title>

<link rel=Stylesheet type="text/css" media=all href="1.css">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
h1
	{margin-top:1.0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:0in;
	text-align:center;
	page-break-before:always;
	font-size:24.0pt;
	font-weight:bold;}
h2
	{page-break-before:always;
	font-size:18.0pt;
	font-weight:bold;}
h3
	{font-size:13.5pt;
	font-weight:bold;}
h4
	{font-size:12.0pt;
	font-weight:bold;}
h5
	{font-size:10.0pt;
	font-weight:bold;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{font-size:12.0pt;
	font-weight:bold;}
p.MsoBodyText3, li.MsoBodyText3, div.MsoBodyText3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	font-size:8.0pt;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin:0in;
	margin-bottom:.0001pt;
	background:navy;
	font-size:12.0pt;}
p
	{font-size:12.0pt;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;}
p.footnote, li.footnote, div.footnote
	{font-size:12.0pt;}
p.monofont, li.monofont, div.monofont
	{font-size:12.0pt;}
p.romanfont, li.romanfont, div.romanfont
	{font-size:12.0pt;}
p.atitle, li.atitle, div.atitle
	{font-size:9.0pt;
	font-weight:bold;}
p.chaptertitle, li.chaptertitle, div.chaptertitle
	{margin-top:0in;
	margin-right:7.5pt;
	margin-bottom:0in;
	margin-left:7.5pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
p.sectiontitle, li.sectiontitle, div.sectiontitle
	{margin-top:0in;
	margin-right:15.0pt;
	margin-bottom:0in;
	margin-left:15.0pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
p.itable, li.itable, div.itable
	{font-size:12.0pt;}
p.tiny, li.tiny, div.tiny
	{font-size:7.0pt;}
p.multiselect, li.multiselect, div.multiselect
	{font-size:7.5pt;}
p.safnavoff, li.safnavoff, div.safnavoff
	{font-size:8.5pt;}
p.safnavon, li.safnavon, div.safnavon
	{font-size:8.5pt;
	font-weight:bold;}
p.navtopbg, li.navtopbg, div.navtopbg
	{background:#990000;
	font-size:12.0pt;}
p.navleftbg, li.navleftbg, div.navleftbg
	{background:#666666;
	font-size:12.0pt;}
p.navleftbgalt, li.navleftbgalt, div.navleftbgalt
	{background:#666666;
	font-size:12.0pt;}
p.navtitle, li.navtitle, div.navtitle
	{font-size:9.0pt;
	font-weight:bold;}
p.nonavtitle, li.nonavtitle, div.nonavtitle
	{font-size:9.0pt;
	font-weight:bold;}
p.bimodoff, li.bimodoff, div.bimodoff
	{font-size:12.0pt;}
p.bimodon, li.bimodon, div.bimodon
	{font-size:12.0pt;}
p.btblinks, li.btblinks, div.btblinks
	{font-size:8.5pt;}
p.btlinksactive, li.btlinksactive, div.btlinksactive
	{font-size:12.0pt;
	font-weight:bold;}
p.inputtext, li.inputtext, div.inputtext
	{font-size:12.0pt;}
p.inputbutton, li.inputbutton, div.inputbutton
	{font-size:12.0pt;
	font-weight:bold;}
p.endsearch, li.endsearch, div.endsearch
	{font-size:12.0pt;
	font-weight:bold;}
p.dropdown, li.dropdown, div.dropdown
	{font-size:12.0pt;}
p.navtoptoolbg, li.navtoptoolbg, div.navtoptoolbg
	{background:black;
	font-size:12.0pt;}
p.headingbarbg, li.headingbarbg, div.headingbarbg
	{background:#333333;
	font-size:12.0pt;}
p.headingsubbarbg, li.headingsubbarbg, div.headingsubbarbg
	{background:#CCCCCC;
	font-size:12.0pt;}
p.headingbartitle, li.headingbartitle, div.headingbartitle
	{font-size:10.5pt;
	font-weight:bold;}
p.headingsubbartitle, li.headingsubbartitle, div.headingsubbartitle
	{font-size:9.0pt;
	font-weight:bold;}
p.tablestripe, li.tablestripe, div.tablestripe
	{background:#EEEEEE;
	font-size:12.0pt;}
p.pgtitle, li.pgtitle, div.pgtitle
	{font-size:12.0pt;
	font-weight:bold;}
p.buyprint, li.buyprint, div.buyprint
	{font-size:7.5pt;}
p.resulthighlight, li.resulthighlight, div.resulthighlight
	{background:lightblue;
	font-size:12.0pt;}
p.pgsubtitle, li.pgsubtitle, div.pgsubtitle
	{font-size:12.0pt;
	font-weight:bold;}
p.helphead, li.helphead, div.helphead
	{font-size:12.0pt;
	font-weight:bold;}
p.helpsubhead, li.helpsubhead, div.helpsubhead
	{font-size:10.0pt;}
p.helpcaption, li.helpcaption, div.helpcaption
	{font-size:10.0pt;}
p.helptab, li.helptab, div.helptab
	{font-size:10.0pt;}
p.sm, li.sm, div.sm
	{font-size:6.0pt;}
p.gowild, li.gowild, div.gowild
	{font-size:13.5pt;
	font-weight:bold;
	font-style:italic;}
p.getstarted, li.getstarted, div.getstarted
	{font-size:10.0pt;
	font-weight:bold;
	font-style:italic;}
span.msoins0
	{text-decoration:underline;}
span.msodel0
	{color:red;
	text-decoration:line-through;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;}
div.Section1
	{page:Section1;}
-->
</style>

</head>

<body lang=EN-US link="#990000" vlink=purple>

<div class=Section1>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%;background:#ECECD9;border-collapse:collapse;border:none'>
 <tr>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="30.htm"><span style='text-decoration:none'><img
  border=0 width=37 height=34 src="leftarrw.gif"></span></a></p>
  </td>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><a href="0.htm"><span
  style='font-size:13.5pt'>Table of Contents</span></a></p>
  </td>
  <td width="34%" style='width:34.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=right style='text-align:right'><a href="32.htm"><span
  style='text-decoration:none'><img border=0 width=37 height=34
  src="rightarrw.gif"></span></a></p>
  </td>
 </tr>
</table>

</div>

<h2><a name="_Appendix_D._Threads"></a>Appendix D. Threads</h2>

<p>Ahh, threads—those little things that seem so simple to understand and to
use, but are so hard to use correctly. The less you have used threads, the simpler
they appear, but speak to any experienced thread programmer, and they can
regale you with tales of all-night sessions tracking down threading-related
bugs nearly impossible to reproduce.</p>

<p>So why an appendix instead of a chapter? Indeed, the question should be why
an appendix instead of a complete book! Threads are deceptively complex,
usually due to the synchronization required between the different threads to
help coordinate their activity. These considerations aren’t specific to
Windows, and there are plenty of excellent references available on threaded
programming independent of the operating system or programming language
available.</p>

<p>We make no attempt to cover the basics of thread programming. Instead, this
appendix attempts to cover only some of the Windows specific threading-related
issues. We don’t attempt to teach thread programming, and certainly won’t
present any complex or real-world threaded examples. We simply restrict
ourselves to discussions of threading-specific issues that may affect you when
using Python on the Windows platform.</p>

<h3><a name="_D.1_Python_Thread_Support"></a>D.1 Python Thread Support</h3>

<p>Python supports threads through a number of built-in modules. For many
threading-related tasks, you are likely to find these modules more than
adequate, your code is portable across all platforms that support threading,
and you have access to the copious documentation and examples available.</p>

<p>The most general-purpose of these modules is the <tt><span style='font-size:
10.0pt'>threading</span></tt> module, which provides an interface modeled after
Java’s threading support. This module provides a <tt><span style='font-size:
10.0pt'>Thread</span></tt> class to manage your threads and also a number of
synchronization objects necessary in any nontrivial threading application.</p>

<p>Here’s a trivial example using the <tt><span style='font-size:10.0pt'>threading</span></tt>
module. Let’s create a new thread as a subclass of the <tt><span
style='font-size:10.0pt'>threading.Thread</span></tt> class and override the <tt><span
style='font-size:10.0pt'>run()</span></tt> method that implements the thread.
Each thread loops five times, printing a message each time. It should be noted
that subclassing the <tt><span style='font-size:10.0pt'>Thread</span></tt>
class is just one way to implement this thread; it’s also possible to implement
the new thread in a normal function.</p>

<p>The main thread creates three worker threads, then waits for them all to
complete, using the <tt><span style='font-size:10.0pt'>join()</span></tt>
method provided by the base class:</p>

<pre># SimpleThreads.py</pre><pre>#</pre><pre># Trivial example of using the Python threading module.</pre><pre>&nbsp;</pre><pre>import Threading</pre><pre>import time</pre><pre>import random</pre><pre>&nbsp;</pre><pre>class SimpleThread(Threading.Thread):</pre><pre>&nbsp;&nbsp;&nbsp; def run(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(5):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print self, i</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.sleep(random.random())</pre><pre>&nbsp;</pre><pre>if __name__=='__main__':</pre><pre>&nbsp;&nbsp;&nbsp; threads = []</pre><pre>&nbsp;&nbsp;&nbsp; for i in range(3):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread = SimpleThread()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.start()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threads.append(thread)</pre><pre>&nbsp;&nbsp;&nbsp; # Now we wait for them to finish.</pre><pre>&nbsp;&nbsp;&nbsp; for thread in threads:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.join()</pre><pre> &nbsp;&nbsp;&nbsp;print &quot;All threads finished&quot;</pre>

<p>Running this script should produce output similar to:</p>

<pre>&lt;SimpleThread(Thread-8, started)&gt; 0</pre><pre>&lt;SimpleThread(Thread-9, started)&gt; 0</pre><pre>&lt;SimpleThread(Thread-10, started)&gt; 0</pre><pre>&lt;SimpleThread(Thread-8, started)&gt; 1</pre><pre>&lt;SimpleThread(Thread-10, started)&gt; 1</pre><pre>&lt;SimpleThread(Thread-8, started)&gt; 2</pre><pre>&lt;SimpleThread(Thread-9, started)&gt; 1</pre><pre>&lt;SimpleThread(Thread-9, started)&gt; 2</pre><pre>&lt;SimpleThread(Thread-10, started)&gt; 2</pre><pre>&lt;SimpleThread(Thread-8, started)&gt; 3</pre><pre>&lt;SimpleThread(Thread-10, started)&gt; 3</pre><pre>&lt;SimpleThread(Thread-9, started)&gt; 3</pre><pre>&lt;SimpleThread(Thread-8, started)&gt; 4</pre><pre>&lt;SimpleThread(Thread-10, started)&gt; 4</pre><pre>&lt;SimpleThread(Thread-9, started)&gt; 4</pre><pre>All threads finished</pre>

<p>As you can see, implementing, starting, and waiting for completion of
threads is quite simple. Please see the Python documentation for more
information on the <tt><span style='font-size:10.0pt'>threading</span></tt>
module, including the various synchronization objects supported by the module.</p>

<h3><a name="_D.2_Win32_Thread_Support"></a>D.2 Win32 Thread Support</h3>

<p>As Python runs on many operating systems, the Python thread support is
limited to a reasonable subset of what a platform can be expected to provide in
the way of threading. Windows provides a number of additional features that
relate to threads and synchronization, and we discuss some of these here.</p>

<h4 style='page-break-after:avoid'>D.2.1 Native Win32 Threads</h4>

<p>The <tt><span style='font-size:10.0pt'>win32process</span></tt> module
provides access to the <tt><span style='font-size:10.0pt'>beginthreadex()</span></tt>
function provided by the Microsoft Visual C++ runtime library. This function
allows you to specify a function as the thread, as well as some custom Win32
setting for the thread.</p>

<p>There are only a small number of situations when it’s necessary to use this
function in preference to the standard <tt><span style='font-size:10.0pt'>threading</span></tt>
module. The first is when you need access to the Win32-specific features, such
as the security for the object or flags that indicate the thread should be
created in a suspended mode. Another common situation is when the main thread
requires the Win32 <tt><span style='font-size:10.0pt'>HANDLE</span></tt> of the
new thread; this is not easy using the other Python threading modules (where
only the new thread itself has easy access to this information).</p>

<h4>D.2.2 win32event Module</h4>

<p>Each application has different synchronization requirements. Some programs
may need to wait for threads to complete, while some threads may need to wait
for a file operation to complete or mutexes to become available. To cater to
these various requirements, Windows bases all its synchronization primitives
around Windows <tt><span style='font-size:10.0pt'>HANDLES</span></tt>. When you
wish to wait for something of significance, you usually pass a handle. For
example, you can wait for a thread or process to complete by specifying its
handle; you can wait for a file operation to complete by waiting on the handle
in the <tt><span style='font-size:10.0pt'>OVERLAPPED</span></tt> object you
specified. You can wait for the mutex, semaphore, event, or other objects by
passing the handle you obtained when opening or creating the object. Thus,
regardless of the type of object or event you are waiting for, you always use
handles and can use the same Win32 functions.</p>

<p>There are three functions exposed by <tt><span style='font-size:10.0pt'>win32event</span></tt>
that wait for Win32 objects: <tt><span style='font-size:10.0pt'>WaitForSingleObject()</span></tt>,
<tt><span style='font-size:10.0pt'>WaitForMultipleObjects()</span></tt>, and <tt><span
style='font-size:10.0pt'>MsgWaitFor-MultipleObjects()</span></tt>. Each of
these functions allow you to wait for one or more handles to become <i>signaled</i>,
but exactly what signaled means depends on the object. For example, a signaled
synchronization object typically means you have acquired the object, a signaled
thread or process handles mean the thread has terminated, and so forth.</p>

<p>Here are the three functions.</p>

<p class=MsoNormal><span class=monofont1><span style='color:#990000'>WaitForSingleObject()</span></span><span
style='font-family:Arial;color:#990000'> </span></p>

<p style='margin-left:.5in'>As the name implies, this function allows you to
wait for a single object to become signaled. It takes two parameters; the
handle to the object you wish to wait for, and a timeout in milliseconds (or <tt><span
style='font-size:10.0pt'>win32event.INFINITE</span></tt> for no timeout). The
return value from the function is <tt><span style='font-size:10.0pt'>win32event.WAIT_OBJECT_0</span></tt>
if the object becomes signaled, <tt><span style='font-size:10.0pt'>win32event.WAIT_TIMEOUT</span></tt>
if the timeout interval expired, or <tt><span style='font-size:10.0pt'>win32event.WAIT_ABANDONED</span></tt>
in certain situations for mutexes (see the Win32 documentation).</p>

<p class=MsoNormal style='page-break-after:avoid'><span class=monofont1><span
style='color:#990000'>WaitForMultipleObjects()</span></span><span
style='font-family:Arial;color:#990000'> </span></p>

<p style='margin-left:.5in'>Allows you wait for one or all of a number of
objects. The first parameter is a sequence (e.g., list or tuple) of handles,
while the second is a boolean flag indicating if you wish the function to
return when all objects are signaled (<tt><span style='font-size:10.0pt'>true</span></tt>)
or when any one of the objects becomes signaled (<tt><span style='font-size:
10.0pt'>false</span></tt>). The third parameter is a timeout interval, as for <tt><span
style='font-size:10.0pt'>WaitForSingleObject()</span></tt>. The return code
from this function is similar to <tt><span style='font-size:10.0pt'>WaitForSingleObject()</span></tt>,
except the result may range from <tt><span style='font-size:10.0pt'>win32event.WAIT_OBJECT_0</span></tt>
to <tt><span style='font-size:10.0pt'>win32event.WAIT_OBJECT_0 + len(handles)-1</span></tt>.
If you indicate you wish to wait for only one of the objects, this tells which
object became signaled. <a href="22.htm#_Chapter_18._Windows_NT_Services">Chapter
18</a>, contains examples of using <tt><span style='font-size:10.0pt'>WaitForMultipleObjects()</span></tt>
to wait for either a service control request or a client connection and
demonstrates how to decode the return values.</p>

<p class=MsoNormal><span class=monofont1><span style='color:#990000'>MsgWaitForMultipleObjects()</span></span><span
style='font-family:Arial;color:#990000'> </span></p>

<p style='margin-left:.5in'>Almost identical to <tt><span style='font-size:
10.0pt'>WaitForMultipleObjects()</span></tt> but also allows you to detect that
a Windows message is ready to be processed by the thread. This information is
particularly relevant for both GUI programs that make use of threading, and
objects that use apartment-threaded COM objects, as described later in this
appendix. Please see <a href="30.htm#_Appendix_C._The_Python_Database_API">Appendix
C</a>, for a description of these functions or the final sample in this
appendix for an example of this function’s usage.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%'>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <h3 align=center style='text-align:center'>The Python Thread Lock</h3>
  <p>Although Python fully supports threads, Python itself is not fully
  free-threaded. Python maintains an internal lock that prevents more than one
  thread from being inside the interpreter at one time. Although this initially
  sounds restricting, there are a number of reasons why it is less of a burden
  in practice.</p>
  <p>Most real-world programs spend their time waiting on the external world
  (such as data to be read from a disk or input to arrive from the keyboard).
  Most Python functions (even in extension modules) that take significant time
  to execute, release the Python lock. This leaves other Python threads free to
  run while this thread is waiting for the call to complete.</p>
  <p>On single-processor machines, there is only one thread on the system executing
  anyway; the operating system provides the illusion that the threads are
  running at the same time. For these machines, the Python thread lock
  typically doesn’t impede threading performance.</p>
  <p>For some applications, where multiple Python threads are waiting on some
  external relatively slow process that can take advantage of multiple
  processors (such as SQL database engines) you may still find that Python’s
  threading model provides all the performance you need. However, if you are
  writing performance-critical applications that will run on multiprocessor
  computers, you should keep these threading restrictions in mind.</p>
  <p>It should also be noted that Guido et al. are considering how to remove
  this threading restriction. Greg Stein made some experimental free-threaded
  patches for Python 1.4 that were the inspiration for some threading changes
  in Python 1.5, but at time of writing, debate is still continuing about
  exactly how to incorporate free-threading changes without severely impacting
  performance for single-threaded programs or on single-processor machines.</p>
  </td>
 </tr>
</table>

</div>

<h3><a name="_D.3_COM_Threading_Models"></a>D.3 COM Threading Models</h3>

<p>For various, and mainly historic, reasons, COM has the concept of threading
models. Most often it’s an implementation detail of little importance, so can
safely be skipped by the casual COM user. A full discussion of COM’s threading
models is beyond the scope of this book (and seemingly beyond the scope of the
COM documentation!), however some detailed information about this esoteric part
of COM may help explain odd behavior you may encounter.</p>

<h4>D.3.1 Apartment Living</h4>

<p>Each object lives in what COM terms a threading apartment, of which there
are two types, free-threaded and single-threaded. A process can have zero or one
free-threaded apartments and any number of single-threaded apartments (one for
each thread with a single-threaded object).</p>

<p>The apartment is nothing more than a conceptual framework invented by COM to
explain the rules and other nuances of using threading with COM. An <i>apartment</i>
is a grouping of objects by their threading characteristics. Before a thread
can use COM, it must indicate its threading model (that is, if a new
single-threaded apartment should be created, or if this thread should live in
the free-threaded apartment). The apartment an object lives in is determined
either by the implementation of the object or the thread that created the
object, as we discuss later.</p>

<p>The point of the COM-threading models is to allow simple objects that aren’t
written with threads in mind to be used by another object that is thread-aware.
If an object is written with the assumption that concurrent access to the
object isn’t possible, then using such an object from multiple threads is
likely to be disastrous. Therefore, threads that reside in the same apartment
can make unrestricted use of all objects in that apartment, but whenever
threads from different apartments (that is, two threads that are not both in
the free-threaded apartment) need to use an object, COM steps in. COM uses what
is known as a <i>proxy</i> to automatically synchronize the threads so the
object is correctly called from a thread in that object’s apartment. COM also
imposes rules to allow this mechanism to work.</p>

<h3><a name="_D.4_What_Apartment_Do_I_Live_in?"></a>D.4 What Apartment Do I
Live in?</h3>

<p>The obvious question to arise from this is “How do I control the apartment
for my threads or objects?” There is no simple answer.</p>

<p>Fortunately, the rules for threads are quite simple. Before a thread can use
COM, it must call one of the <tt><span style='font-size:10.0pt'>CoInitialize()</span></tt>
or <tt><span style='font-size:10.0pt'>CoInitializeEx()</span></tt> functions
and when it’s done with COM, it must call <tt><span style='font-size:10.0pt'>CoUninitialize()</span></tt>;
these functions are exposed to Python by the <tt><span style='font-size:10.0pt'>pythoncom</span></tt>
module. <tt><span style='font-size:10.0pt'>CoInitialize()</span></tt> predates
the COM threading models, so it initializes a new single-threaded apartment for
the thread. <tt><span style='font-size:10.0pt'>CoInitializeEx()</span></tt>
takes an additional parameter that allows you to specify the threading model;
thus, you must use this function to have your thread in the free-threading
apartment. The first single-threaded apartment created (that is, the first thread
that calls either <tt><span style='font-size:10.0pt'>CoInitialize()</span></tt>
or <tt><span style='font-size:10.0pt'>CoInitializeEx()</span></tt> with the <tt><span
style='font-size:10.0pt'>COINIT_APARTMENTTHREADED</span></tt> flag) is given
special significance as we discuss later, and is known as the main
single-threaded apartment.</p>

<p>To hide some of this complexity, Python calls <tt><span style='font-size:
10.0pt'>CoInitializeEx()</span></tt> automatically as soon as the <tt><span
style='font-size:10.0pt'>pythoncom</span></tt> module is imported, and this is
significant for the following reasons:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>The threading apartment for the first Python thread that imports the <tt><span
style='font-size:10.0pt'>pythoncom</span></tt> module is controlled by this
automatic process. By default, this thread is initialized in a single-threaded
apartment, but this can be controlled by adding a <tt><span style='font-size:
10.0pt'>co_initflags</span></tt> attribute to the <tt><span style='font-size:
10.0pt'>sys</span></tt> module before importing <tt><span style='font-size:
10.0pt'>pythoncom</span></tt> (see the final sample in this appendix). If this
attribute exists, it’s passed unchanged to the <tt><span style='font-size:10.0pt'>CoInitializeEx()</span></tt>
function by the PythonCOM framework. For example, you could execute the
following code to ensure the main thread is initialized in the multithreaded
apartment:</p>

<pre style='margin-left:.5in;text-indent:-.25in'><span style='font-family:Symbol'>·</span><span
style='font-size:7.0pt;font-family:"Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>import sys</pre><pre
style='margin-left:.5in;text-indent:-.25in'><span style='font-family:Symbol'>·</span><span
style='font-size:7.0pt;font-family:"Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>sys.coinit_flags = 0 # pythoncom.COINIT_MULTITHREADED = 0</pre><pre
style='margin-left:.5in'>import pythoncom</pre>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>As the default behavior is to initialize a single-threaded apartment,
this Python thread may also become the main single-threaded apartment, as
discussed previously. The implications for the main single-threaded apartment
are discussed later in this appendix.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Only this main thread has <tt><span style='font-size:10.0pt'>CoInitializeEx()</span></tt>
called automatically.<a name="_ftnref31"></a><a href="#_ftn31"><span
class=atitlechar><sup><span style='font-size:9.0pt'>[A]</span></sup></span></a>
Any other threads you create need to call <tt><span style='font-size:10.0pt'>pythoncom.CoInitializeEx()</span></tt>
explicitly before using COM and <tt><span style='font-size:10.0pt'>pythoncom.CoUninitialize()</span></tt>
when complete.</p>

<p>The rules for which object an apartment lives in are slightly more complex.
If the COM object in question is implemented in any way other than an <tt><span
style='font-size:10.0pt'>InProc</span></tt> DLL (for example, a LocalServer or
RemoteServer EXE-based object), the question becomes moot, as the object is
running in a separate process, and therefore can not be in the same apartment.
For DLL-implemented objects, the apartment is determined both by the apartment
of the thread creating the object and the threading models actually supported
by the object.</p>

<p>When an <tt><span style='font-size:10.0pt'>InProc</span></tt> object is
registered, part of the information written to the registry is the threading
models supported by the object. This can be either <tt><span style='font-size:
10.0pt'>Apartment</span></tt>, to indicate the object must live in a
single-threaded apartment, <tt><span style='font-size:10.0pt'>Free</span></tt>
to indicate the object must live in the multithreaded apartment, or <tt><span
style='font-size:10.0pt'>Both</span></tt> if the object supports either
technique. As discussed in <a href="16.htm#_Chapter_12._Advanced_Python_and_COM">Chapter
12</a>, this is controlled for Python objects via the <tt><span
style='font-size:10.0pt'>_reg_threading_</span></tt> attribute, with the
default for Python objects being <tt><span style='font-size:10.0pt'>Both</span></tt>.</p>

<p>If the thread creating the object and the object itself have compatible
threading models, the object is created in the thread’s apartment. If the
object is an old COM object (indicated by the lack of threading information in
the object’s registration information) the object may be created in the main
single-threaded apartment. If a multithreaded apartment needs to create a single-threaded
object, COM automatically creates a new single-threaded apartment for the new
object.</p>

<h4>D.4.1 What Are the Apartment Rules?</h4>

<p>For all this complicated machinery to work, there are a number of rules COM
imposes on programs that use COM.</p>

<p>The synchronization of calls between different threads is achieved using
Windows messages. This means that all threads in a single-threaded apartment
must run a message loop to allow this mechanism to work. If the program is a
GUI (such as PythonWin) this is no problem, but for most other applications,
including Windows Services, this may not be an existing requirement. In
practice, this means if any of your threads that exist in a single-threaded COM
apartment need to wait on some synchronization object, you may need to use
either the <tt><span style='font-size:10.0pt'>win32event.MsgWaitForSingleObject()</span></tt>
or <tt><span style='font-size:10.0pt'>win32event.MsgWaitForMultipleObjects()</span></tt>
calls so you can still process messages at the appropriate time. If you have no
other message requirements, calling <tt><span style='font-size:10.0pt'>pythoncom.PumpWaitingMessages()</span></tt>
processes all messages currently in the thread’s queue. This technique is
demonstrated in the example in the next section.</p>

<p>The other major rule imposed by the COM threading models is that it’s
illegal to pass COM interface pointers (and therefore the Python wrappers) between
threads. As you may be passing the pointer from the same apartment to a
different apartment, you may be avoiding or violating the synchronization
mechanisms (and other optimizations) provided by COM. To pass interface objects
between threads, you must use the <tt><span style='font-size:10.0pt'>pythoncom.CoMarshalInterThreadInterface-InStream()</span></tt>
and <tt><span style='font-size:10.0pt'>pythoncom.CoGetInterfaceAndReleaseStream()</span></tt>
functions to transfer objects between threads. These functions are demonstrated
next.</p>

<h4>D.4.2 Apartments Open for Inspection</h4>

<p>It’s time to demonstrate some of these concepts. To do this, we develop
three COM objects, each of which support one of the various threading models
discussed previously. These COM objects are quite simple and expose only two
methods: <tt><span style='font-size:10.0pt'>GetCreatedThreadId()</span></tt> to
return the thread ID of the thread that created the object, and <tt><span
style='font-size:10.0pt'>GetCurrentThreadId()</span></tt> to return the thread
ID of the current thread (that is, the thread receiving the call). If you have
read <a href="16.htm#_Chapter_12._Advanced_Python_and_COM">Chapter 12</a>,
there will be nothing new in this example. The only points worth mentioning are
that we use <tt><span style='font-size:10.0pt'>win32api.GetCurrentThreadId()</span></tt>
to obtain the Win32 Thread ID, and that we use a Python base class for the raw
COM functionality, and subclasses for the object-specific registration
information. The COM objects are implemented in <i>ThreadingModelsServer.py</i>
:</p>

<pre># ThreadingModelsServer.py</pre><pre># Python COM objects that demonstrate COM threading models.</pre><pre>#</pre><pre># Exposes 3 Python objects, all of which have identical functionality,</pre><pre># but each indicate they support different threading models.</pre><pre>&nbsp;</pre><pre>import win32api</pre><pre># A Base class for our 2 trivial objects.</pre><pre>class ThreadDemoObject:</pre><pre>&nbsp;&nbsp;&nbsp; _public_methods_ = [ 'GetCurrentThreadId', 'GetCreatedThreadId' ]</pre><pre>&nbsp;&nbsp;&nbsp; def __init__(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.created_id = win32api.GetCurrentThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; def GetCreatedThreadId(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.created_id</pre><pre>&nbsp;&nbsp;&nbsp; def GetCurrentThreadId(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Simply return an integer with the Win32 thread ID.</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return win32api.GetCurrentThreadId()</pre><pre>&nbsp;</pre><pre>class ThreadApartmentObject(ThreadDemoObject):</pre><pre>&nbsp;&nbsp;&nbsp; _reg_threading_ = &quot;Apartment&quot; # Tell COM to synchronize</pre><pre>&nbsp;&nbsp;&nbsp; _reg_progid_ = &quot;PythonThreadDemo.Apartment&quot;</pre><pre>&nbsp;&nbsp;&nbsp; _reg_clsid_ = &quot;{511BB541-4625-11D3-855B-204C4F4F5020}&quot;</pre><pre>&nbsp;</pre><pre>class ThreadFreeObject(ThreadDemoObject):</pre><pre>&nbsp;&nbsp;&nbsp; _reg_threading_ = &quot;Free&quot;</pre><pre>&nbsp;&nbsp;&nbsp; _reg_progid_ = &quot;PythonThreadDemo.Free&quot;</pre><pre>&nbsp;&nbsp;&nbsp; _reg_clsid_ = &quot;{511BB542-4625-11D3-855B-204C4F4F5020}&quot;</pre><pre>&nbsp;</pre><pre>class ThreadBothObject(ThreadDemoObject):</pre><pre>&nbsp;&nbsp;&nbsp; _reg_threading_ = &quot;Both&quot;</pre><pre>&nbsp;&nbsp;&nbsp; _reg_progid_ = &quot;PythonThreadDemo.Both&quot;</pre><pre>&nbsp;&nbsp;&nbsp; _reg_clsid_ = &quot;{511BB543-4625-11D3-855B-204C4F4F5020}&quot;</pre><pre>&nbsp;</pre><pre>if __name__=='__main__':</pre><pre>&nbsp;&nbsp;&nbsp; import win32com.server.register</pre><pre>&nbsp;&nbsp;&nbsp; win32com.server.register.UseCommandLine(</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThreadApartmentObject,</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThreadFreeObject,</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThreadBothObject)</pre>

<p>Before moving to the client sample code, these objects must be registered in
the normal way.</p>

<p>The code that uses these COM objects is considerably more complex because
it’s here the COM object, and the threads that use it, are created. The general
intent of the code is to create the single-threaded object we defined and then
create three threads that use this object. The code confirms that so long as
you follow the COM rules, COM ensures that regardless of the thread actually
calling the object, the object will see the call on its single thread (i.e.,
the thread that created it.) You then execute the same code but create the
free-threaded version of the object, and observe the differences.</p>

<p>Before launching into the code, there are some points to discuss:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>The main thread needs to wait for the subthreads to complete, but as you
will be running single-threaded objects in the apartment, you need to process
Windows messages. Therefore use the <tt><span style='font-size:10.0pt'>win32process.beginthreadex()</span></tt>
function to create the thread, so that you can use the thread handles with <tt><span
style='font-size:10.0pt'>win32event.MsgWaitForMultipleObjects()</span></tt>.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>All the threads exist in separate single-threaded apartments; the main
thread because we haven’t overridden the default Python initialization by
setting <tt><span style='font-size:10.0pt'>sys.coinit_flags</span></tt>, and
each worker thread because each calls <tt><span style='font-size:10.0pt'>pythoncom.CoInitialize()</span></tt>
rather than <tt><span style='font-size:10.0pt'>pythoncom.CoInitializeEx()</span></tt>.
Because all the threads are in different apartments, you must use the <tt><span
style='font-size:10.0pt'>CoMarshalInterThreadInterfaceInStream()</span></tt>
and <tt><span style='font-size:10.0pt'>CoGetInterfaceAnd-ReleaseStream()</span></tt>
functions to transfer the COM object between threads.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><tt><span style='font-size:10.0pt'>MsgWaitForMultipleObjects()</span></tt>
has a quirk that usually prevents effective use of the <tt><span
style='font-size:10.0pt'>bWaitAll</span></tt> parameter. If set to <tt><span
style='font-size:10.0pt'>true</span></tt>, the function waits until all objects
have been signaled, and input is available. Generally, you need to know when
all objects are signaled, or input is available. You can avoid this restriction
by setting <tt><span style='font-size:10.0pt'>bWaitAll</span></tt> to <tt><span
style='font-size:10.0pt'>false</span></tt>, and each time a thread completes
remove its handle from the list before waiting again.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>The main body of the sample code accepts the name of the COM object as a
parameter. This lets you run the same code with both the single-threaded and
free-threaded versions of the COM object.</p>

<p>The code is presented in <i>SingleThreadedApartment.py </i>:</p>

<pre># SingleThreadedApartment.py</pre><pre># Demonstrate the use of multiple threads, each in their own</pre><pre># single-threaded apartment.</pre><pre>&nbsp;</pre><pre># As we do not set sys.coinit_flags=0</pre><pre># before the Pythoncom import, Python</pre><pre># initializes the main thread for single threading.</pre><pre>from pythoncom import \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; CoInitialize, CoUninitialize, IID_IDispatch,\</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; CoMarshalInterThreadInterfaceInStream, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; CoGetInterfaceAndReleaseStream, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; PumpWaitingMessages</pre><pre>&nbsp;</pre><pre>from win32event import \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; MsgWaitForMultipleObjects, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; QS_ALLINPUT, WAIT_TIMEOUT, WAIT_OBJECT_0</pre><pre>&nbsp;</pre><pre>from win32com.client import Dispatch</pre><pre>from win32process import beginthreadex</pre><pre>from win32api import GetCurrentThreadId</pre><pre>&nbsp;</pre><pre>def Demo( prog_id ):</pre><pre>&nbsp;&nbsp;&nbsp; # First create the object</pre><pre>&nbsp;&nbsp;&nbsp; object = Dispatch(prog_id)</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Thread&quot;, GetCurrentThreadId(), &quot;creating object&quot;</pre><pre>&nbsp;&nbsp;&nbsp; created_id = object.GetCreatedThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Object reports it was created on thread&quot;, created_id</pre><pre>&nbsp;&nbsp;&nbsp; # Now create the threads, remembering the handles.</pre><pre>&nbsp;&nbsp;&nbsp; handles = []</pre><pre>&nbsp;&nbsp;&nbsp; for i in range(3):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # As we are not allowed to pass the object directly between</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # apartments, we need to marshal it.</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_stream = CoMarshalInterThreadInterfaceInStream(</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IID_IDispatch, object )</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Build an argument tuple for the thread.</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args = (object_stream,)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle, id = beginthreadex(None, 0, WorkerThread, args, 0)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handles.append(handle)</pre><pre>&nbsp;&nbsp;&nbsp; # Now we have all the threads running, wait for them to terminate.</pre><pre>&nbsp;&nbsp;&nbsp; # also remember how many times we are asked to pump messages.</pre><pre>&nbsp;&nbsp;&nbsp; num_pumps = 0</pre><pre>&nbsp;&nbsp;&nbsp; while handles:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # A quirk in MsgWaitForMultipleObjects means we must wait</pre><pre># for each event one at a time</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = MsgWaitForMultipleObjects(handles, 0, 5000, QS_ALLINPUT)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if rc &gt;= WAIT_OBJECT_0 and rc &lt; WAIT_OBJECT_0+len(handles):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # A thread finished - remove its handle.</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; del handles[rc-WAIT_OBJECT_0]</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif rc==WAIT_OBJECT_0 + len(handles):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Waiting message</pre><pre>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_pumps = num_pumps + 1</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PumpWaitingMessages()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print &quot;Nothing seems to be happening&quot;,</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print &quot;but I will keep waiting anyway...&quot;</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Pumped messages&quot;, num_pumps, &quot;times&quot;</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Demo of&quot;, prog_id, &quot;finished.&quot;</pre><pre>&nbsp;</pre><pre>def WorkerThread(object_stream):</pre><pre>&nbsp;&nbsp;&nbsp; # First step - initialize COM</pre><pre>&nbsp;&nbsp;&nbsp; CoInitialize() # Single-threaded.</pre><pre>&nbsp;&nbsp;&nbsp; # Unmarshal the IDispatch object.</pre><pre>&nbsp;&nbsp;&nbsp; object = CoGetInterfaceAndReleaseStream(</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_stream, IID_IDispatch)</pre><pre>&nbsp;&nbsp;&nbsp; # The object we get back is a PyIDispatch, rather</pre><pre>&nbsp;&nbsp;&nbsp; # than a friendly Dispatch instance, so we convert</pre><pre>&nbsp;&nbsp;&nbsp; # to a usable object.</pre><pre>&nbsp;&nbsp;&nbsp; object = Dispatch(object)</pre><pre>&nbsp;&nbsp;&nbsp; this_id = GetCurrentThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; that_id = object.GetCurrentThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; message = &quot;Thread is %d, and object is on thread %d&quot; % \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (this_id, that_id)</pre><pre>&nbsp;&nbsp;&nbsp; print message</pre><pre>&nbsp;&nbsp;&nbsp; # Be a good citizen and finalize COM, but</pre><pre>&nbsp;&nbsp;&nbsp; # first remove our object references.</pre><pre>&nbsp;&nbsp;&nbsp; object = None</pre><pre>&nbsp;&nbsp;&nbsp; CoUninitialize()</pre><pre>&nbsp;</pre><pre>if __name__=='__main__':</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Running with Apartment Threaded object&quot;</pre><pre>&nbsp;&nbsp;&nbsp; Demo(&quot;PythonThreadDemo.Apartment&quot;)</pre><pre>&nbsp;&nbsp;&nbsp; print</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Running with Free Threaded object&quot;</pre><pre>&nbsp;&nbsp;&nbsp; Demo(&quot;PythonThreadDemo.Free&quot;)</pre>

<p>You should run this code from a command prompt rather than PythonWin or
IDLE, just to ensure that the threading doesn’t interfere with these
applications. When run, the output from this script should be similar to:</p>

<pre>Running with Apartment Threaded object</pre><pre>Thread 355 creating object</pre><pre>Object reports it was created on thread 355</pre><pre>Thread is 354, and object is on thread 355</pre><pre>Thread is 314, and object is on thread 355</pre><pre>Thread is 306, and object is on thread 355</pre><pre>Pumped messages 9 times</pre><pre>Demo of PythonThreadDemo.Apartment finished.</pre><pre>&nbsp;</pre><pre>Running with Free Threaded object</pre><pre>Thread 355 creating object</pre><pre>Object reports it was created on thread 318</pre><pre>Thread is 326, and object is on thread 433</pre><pre>Thread is 399, and object is on thread 433</pre><pre>Thread is 362, and object is on thread 318</pre><pre>Pumped messages 0 times</pre><pre>Demo of PythonThreadDemo.Free finished.</pre>

<p>The output before the blank line represents the single-threaded object, so let’s
examine that first. The main Python thread reports itself as thread 355, and
the object itself was also created on thread 355, as expected. Each of the
three threads that started to use the object does indeed get a unique thread
ID, but regardless of the thread making the call, the object always sees the
call on thread 355, the thread that created the object. You can also see that
while this simple test was running, and the main thread was waiting for the
threads to terminate, you were called upon nine times to process Windows
messages.</p>

<p>The output after the blank line represents the same test code, but uses the
free-threaded object. As you can see, the same main thread is creating the COM
object, but this time the object reports it was created on thread 318. As this
thread is in a single-threaded apartment, and the COM object insists on a
free-threading apartment, COM has spun up a new thread to host the object. As
each thread calls the object, the object itself isn’t restricted to receiving
the call on a single thread. Because you’re in different apartments the threads
are still different, but the same single-threaded restrictions don’t apply.
Also notice that in this scenario, it’s not strictly necessary to run a message
pump, as there are no single-threaded COM objects being hosted on the main
thread.</p>

<p>To help complete the picture, we now present a fully multithreaded example.
It’s almost identical to the one just presented, with the following changes:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>The main thread is forced into the free-threaded apartment by setting <tt><span
style='font-size:10.0pt'>sys.coinit_flags</span></tt> to zero before importing <tt><span
style='font-size:10.0pt'>pythoncom</span></tt>. Each worker thread is forced by
calling <tt><span style='font-size:10.0pt'>pythoncom.CoInitializeEx()</span></tt>.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Since all the threads are in the free-threading apartment, you can
freely pass COM objects between threads and avoid those functions with the huge
names!</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Since you don’t need to process messages, replace the convoluted <tt><span
style='font-size:10.0pt'>MsgWaitForMultipleObjects()</span></tt> call with a
single <tt><span style='font-size:10.0pt'>WaitForMultiple-Objects()</span></tt>
call. Ideally this code would use the Python threading model, but we’ve kept
the basic code layout so it’s easy to compare the differences.</p>

<p>The code is presented in <i>FreeThreadedApartment.py </i>:</p>

<pre># FreeThreadedApartment.py</pre><pre># Demonstrate the use of multiple threads all in the same</pre><pre># multithreading apartment.</pre><pre>&nbsp;</pre><pre># before the Pythoncom import, we specify free-threading.</pre><pre>import sys</pre><pre>sys.coinit_flags=0</pre><pre>&nbsp;</pre><pre>from pythoncom import \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; CoInitializeEx, CoUninitialize, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; COINIT_MULTITHREADED</pre><pre>&nbsp;</pre><pre>from win32event import \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; WaitForMultipleObjects, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp; WAIT_ABANDONED</pre><pre>&nbsp;</pre><pre>from win32com.client import Dispatch</pre><pre>from win32process import beginthreadex</pre><pre>from win32api import GetCurrentThreadId</pre><pre>&nbsp;</pre><pre>def Demo( prog_id ):</pre><pre>&nbsp;&nbsp;&nbsp; # First create the object</pre><pre>&nbsp;&nbsp;&nbsp; object = Dispatch(prog_id)</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Thread&quot;, GetCurrentThreadId(), &quot;creating object&quot;</pre><pre>&nbsp;&nbsp;&nbsp; created_id = object.GetCreatedThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Object reports it was created on thread&quot;, created_id</pre><pre>&nbsp;&nbsp;&nbsp; # Now create the threads, remembering the handles.</pre><pre>&nbsp;&nbsp;&nbsp; handles = []</pre><pre>&nbsp;&nbsp;&nbsp; for i in range(3):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Multi-threaded - just pass the objects directly to the thread.</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args = (object,)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle, id = beginthreadex(None, 0, WorkerThread, args, 0)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handles.append(handle)</pre><pre>&nbsp;&nbsp;&nbsp; # Now we have all the threads running, wait for them to terminate.</pre><pre>&nbsp;&nbsp;&nbsp; # No need for message pump, so we can simply wait for all objects</pre><pre>&nbsp;&nbsp;&nbsp; # in one call.</pre><pre>&nbsp;&nbsp;&nbsp; rc = WaitForMultipleObjects(handles, 1, 5000)</pre><pre>&nbsp;&nbsp;&nbsp; if rc == WAIT_ABANDONED:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print &quot;Gave up waiting for the threads to finish!&quot;</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Demo of&quot;, prog_id, &quot;finished.&quot;</pre><pre>&nbsp;</pre><pre>def WorkerThread(object):</pre><pre>&nbsp;&nbsp;&nbsp; # First step - initialize COM</pre><pre>&nbsp;&nbsp;&nbsp; CoInitializeEx(COINIT_MULTITHREADED)</pre><pre>&nbsp;&nbsp;&nbsp; this_id = GetCurrentThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; that_id = object.GetCurrentThreadId()</pre><pre>&nbsp;&nbsp;&nbsp; message = &quot;Thread is %d, and object is on thread %d&quot; % \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (this_id, that_id)</pre><pre>&nbsp;&nbsp;&nbsp; print message</pre><pre>&nbsp;&nbsp;&nbsp; # Be a good citizen and finalize COM, but</pre><pre>&nbsp;&nbsp;&nbsp; # first remove our object references.</pre><pre>&nbsp;&nbsp;&nbsp; object = None</pre><pre>&nbsp;&nbsp;&nbsp; CoUninitialize()</pre><pre>&nbsp;</pre><pre>if __name__=='__main__':</pre><pre>&nbsp;&nbsp;&nbsp; print &quot;Running Free threaded with Free Threaded object&quot;</pre><pre>&nbsp;&nbsp;&nbsp; Demo(&quot;PythonThreadDemo.Free&quot;)</pre>

<p>When you run this script, the output should be similar to:</p>

<pre>Running Free threaded with Free Threaded object</pre><pre>Thread 329 creating object</pre><pre>Object reports it was created on thread 329</pre><pre>Thread is 340, and object is on thread 340</pre><pre>Thread is 324, and object is on thread 324</pre><pre>Thread is 444, and object is on thread 444</pre><pre>Demo of PythonThreadDemo.Free finished.</pre>

<p>This is exactly as expected: each call to the object is completely
transparent, just like a regular function call, and always occurs on the thread
that initiated the call. If you wish to get your hands even dirtier, you may
wish to modify these examples to demonstrate every other possible combination
of threads, objects, and threading apartments!</p>

<h4>D.4.3 More Information on COM Threading</h4>

<p>There are a number of technical articles and snippets from books available
from Microsoft, from MSDN, or online at <a href="http://msdn.microsoft.com/"
target="_blank">http://msdn.microsoft.com/</a>. A good starting point for more
information is Knowledge Base Article Q150777 (online at <a
href="http://support.microsoft.com/support/kb/articles/q150/7/77.asp"
target="_blank">http://support.microsoft.com/support/kb/articles/q150/7/77.asp</a>).</p>

<h3><a name="_D.5_Threads_and_the_User_Interface"></a>D.5 Threads and the User
Interface</h3>

<p>Windows has a fairly flexible threading interface when it comes to the
windows and other parts of the user interface, but there are still a number of
restrictions.</p>

<p>Almost any thread in the system can create a window, but only the thread that
created the window can process messages for it. In addition, it’s generally not
a good idea to call window functions from threads other than the thread that
created the window. Using the <tt><span style='font-size:10.0pt'>PostMessage</span></tt>
functions is fine, but be careful using any function that either directly or
indirectly causes a message to be sent a window bypassing the message queue. As
this is a Win32 restriction rather than a Python one, the restriction applies
whether you use PythonWin, Tkinter, wxPython or some other GUI framework on Win32.</p>

<p>Microsoft provide some excellent articles on threading considerations when
using windows from the Win32 API, which you should review for further
information.</p>

<h3><a name="_D.6_Conclusion"></a>D.6 Conclusion</h3>

<p>This appendix has discussed some of the major threading issues you will encounter
using Python on Win32. We have made absolutely no attempt to explain either
thread programming in general, or the many threading and synchronization
functions available on the Win32 platforms. We simply tried to explain the
Python-specific issues when using these functions.</p>

<p>For further information on Python’s standard threading capabilities, please
see the Python documentation optionally installed with the Python binaries. For
more information on the Win32 threading and synchronization capabilities, please
see the Microsoft Win32 documentation. </p>

<p class=MsoFootnoteText><a name="_ftn31"></a><a
href="31.htm#_ftnref31" title=""><span
class=MsoFootnoteReference>[A]</span></a> <tt>CoUninitialize()</tt><span
style='font-size:7.5pt'> isn’t called for the main Python thread automatically,
as doing so can often cause more problems than it solves. This function can
still be called manually from the main thread.</span></p>

<p class=MsoNormal>&nbsp;</p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%;background:#ECECD9;border-collapse:collapse;border:none'>
 <tr>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="30.htm"><span style='text-decoration:none'><img
  border=0 width=37 height=34 src="leftarrw.gif"></span></a></p>
  </td>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><a href="0.htm"><span
  style='font-size:13.5pt'>Table of Contents</span></a></p>
  </td>
  <td width="34%" style='width:34.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=right style='text-align:right'><a href="32.htm"><span
  style='text-decoration:none'><img border=0 width=37 height=34
  src="rightarrw.gif"></span></a></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

</div>

</body>

</html>
