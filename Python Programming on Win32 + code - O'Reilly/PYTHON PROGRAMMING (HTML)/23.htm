<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 10 (filtered)">
<title> </title>

<link rel=Stylesheet type="text/css" media=all href="1.css">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
h1
	{margin-top:1.0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:0in;
	text-align:center;
	page-break-before:always;
	font-size:24.0pt;
	font-weight:bold;}
h2
	{page-break-before:always;
	font-size:18.0pt;
	font-weight:bold;}
h3
	{font-size:13.5pt;
	font-weight:bold;}
h4
	{font-size:12.0pt;
	font-weight:bold;}
h5
	{font-size:10.0pt;
	font-weight:bold;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{font-size:12.0pt;
	font-weight:bold;}
p.MsoBodyText3, li.MsoBodyText3, div.MsoBodyText3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	font-size:8.0pt;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin:0in;
	margin-bottom:.0001pt;
	background:navy;
	font-size:12.0pt;}
p
	{font-size:12.0pt;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;}
p.footnote, li.footnote, div.footnote
	{font-size:12.0pt;}
p.monofont, li.monofont, div.monofont
	{font-size:12.0pt;}
p.romanfont, li.romanfont, div.romanfont
	{font-size:12.0pt;}
p.atitle, li.atitle, div.atitle
	{font-size:9.0pt;
	font-weight:bold;}
p.chaptertitle, li.chaptertitle, div.chaptertitle
	{margin-top:0in;
	margin-right:7.5pt;
	margin-bottom:0in;
	margin-left:7.5pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
p.sectiontitle, li.sectiontitle, div.sectiontitle
	{margin-top:0in;
	margin-right:15.0pt;
	margin-bottom:0in;
	margin-left:15.0pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
p.itable, li.itable, div.itable
	{font-size:12.0pt;}
p.tiny, li.tiny, div.tiny
	{font-size:7.0pt;}
p.multiselect, li.multiselect, div.multiselect
	{font-size:7.5pt;}
p.safnavoff, li.safnavoff, div.safnavoff
	{font-size:8.5pt;}
p.safnavon, li.safnavon, div.safnavon
	{font-size:8.5pt;
	font-weight:bold;}
p.navtopbg, li.navtopbg, div.navtopbg
	{background:#990000;
	font-size:12.0pt;}
p.navleftbg, li.navleftbg, div.navleftbg
	{background:#666666;
	font-size:12.0pt;}
p.navleftbgalt, li.navleftbgalt, div.navleftbgalt
	{background:#666666;
	font-size:12.0pt;}
p.navtitle, li.navtitle, div.navtitle
	{font-size:9.0pt;
	font-weight:bold;}
p.nonavtitle, li.nonavtitle, div.nonavtitle
	{font-size:9.0pt;
	font-weight:bold;}
p.bimodoff, li.bimodoff, div.bimodoff
	{font-size:12.0pt;}
p.bimodon, li.bimodon, div.bimodon
	{font-size:12.0pt;}
p.btblinks, li.btblinks, div.btblinks
	{font-size:8.5pt;}
p.btlinksactive, li.btlinksactive, div.btlinksactive
	{font-size:12.0pt;
	font-weight:bold;}
p.inputtext, li.inputtext, div.inputtext
	{font-size:12.0pt;}
p.inputbutton, li.inputbutton, div.inputbutton
	{font-size:12.0pt;
	font-weight:bold;}
p.endsearch, li.endsearch, div.endsearch
	{font-size:12.0pt;
	font-weight:bold;}
p.dropdown, li.dropdown, div.dropdown
	{font-size:12.0pt;}
p.navtoptoolbg, li.navtoptoolbg, div.navtoptoolbg
	{background:black;
	font-size:12.0pt;}
p.headingbarbg, li.headingbarbg, div.headingbarbg
	{background:#333333;
	font-size:12.0pt;}
p.headingsubbarbg, li.headingsubbarbg, div.headingsubbarbg
	{background:#CCCCCC;
	font-size:12.0pt;}
p.headingbartitle, li.headingbartitle, div.headingbartitle
	{font-size:10.5pt;
	font-weight:bold;}
p.headingsubbartitle, li.headingsubbartitle, div.headingsubbartitle
	{font-size:9.0pt;
	font-weight:bold;}
p.tablestripe, li.tablestripe, div.tablestripe
	{background:#EEEEEE;
	font-size:12.0pt;}
p.pgtitle, li.pgtitle, div.pgtitle
	{font-size:12.0pt;
	font-weight:bold;}
p.buyprint, li.buyprint, div.buyprint
	{font-size:7.5pt;}
p.resulthighlight, li.resulthighlight, div.resulthighlight
	{background:lightblue;
	font-size:12.0pt;}
p.pgsubtitle, li.pgsubtitle, div.pgsubtitle
	{font-size:12.0pt;
	font-weight:bold;}
p.helphead, li.helphead, div.helphead
	{font-size:12.0pt;
	font-weight:bold;}
p.helpsubhead, li.helpsubhead, div.helpsubhead
	{font-size:10.0pt;}
p.helpcaption, li.helpcaption, div.helpcaption
	{font-size:10.0pt;}
p.helptab, li.helptab, div.helptab
	{font-size:10.0pt;}
p.sm, li.sm, div.sm
	{font-size:6.0pt;}
p.gowild, li.gowild, div.gowild
	{font-size:13.5pt;
	font-weight:bold;
	font-style:italic;}
p.getstarted, li.getstarted, div.getstarted
	{font-size:10.0pt;
	font-weight:bold;
	font-style:italic;}
span.msoins0
	{text-decoration:underline;}
span.msodel0
	{color:red;
	text-decoration:line-through;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;}
div.Section1
	{page:Section1;}
-->
</style>

</head>

<body lang=EN-US link="#990000" vlink=purple>

<div class=Section1>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%;background:#ECECD9;border-collapse:collapse;border:none'>
 <tr>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="22.htm"><span style='text-decoration:none'><img
  border=0 width=37 height=34 src="leftarrw.gif"></span></a></p>
  </td>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><a href="0.htm"><span
  style='font-size:13.5pt'>Table of Contents</span></a></p>
  </td>
  <td width="34%" style='width:34.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=right style='text-align:right'><a href="24.htm"><span
  style='text-decoration:none'><img border=0 width=37 height=34
  src="rightarrw.gif"></span></a></p>
  </td>
 </tr>
</table>

</div>

<h2><a name="_Chapter_19._Communications"></a>Chapter 19. Communications</h2>

<p>This chapter surveys three completely different subjects that don’t really
fit together, but don’t belong anywhere else either:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Serial communications, otherwise known as your COM port</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Remote access services, a set of Windows functions for configuring,
making, and breaking dial-up connections to another computer</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Sockets, the interface to the TCP/IP protocol and the layer on top of
which the various Internet protocols such as FTP and HTTP are built</p>

<p>Each is a subject in its own right, and the techniques are not specific to
Python. We’ll show enough to get you started with the right Python extensions
and features and try to point you at some of the right sources to learn more.</p>

<h3><a name="_19.1_Serial_Communications"></a>19.1 Serial Communications</h3>

<p>The serial port has been a part of the standard PC since its inception, and
a wide range of PC accessories, scientific, and medical devices use it; modems
and mice are the most common. Recently, infrared ports have been gaining in
popularity, and these are essentially just serial ports without wires. We will
learn a little about serial ports and use that to talk to some external
devices.</p>

<h4>19.1.1 How COM Ports Are Accessed</h4>

<p>Serial data is carried as a sequence of high and low voltages over a number
of wires with fairly precise timing characteristics. Fortunately for the
programmer, it isn’t necessary to know much about how serial ports work. Under
DOS, you had to work with a very low-level interface; a certain range of bytes
(starting at 0x03F8 for COM1 and 0x02F8 for COM2) contained information about
the serial port. Your program would loop continually checking the values of
bits and bytes in this region; some of these signaled the arrival of data,
others the data values itself, and others error values. It was messy and
painful to program.</p>

<p>Windows 3.1 exposed a higher-level API, with a layer of buffering; functions
such as <tt><span style='font-size:10.0pt'>ReadComm</span></tt> and <tt><span
style='font-size:10.0pt'>WriteComm</span></tt> that provide insulation from the
hardware and a somewhat file-like interface; and event-driven communications,
which allowed you to have messages sent to a window when data arrived at the
COM port. Windows NT drops the windows message concept and completes the move
to a file-like interface, using the same functions to open, read and write COM
ports as regular files. It also prevents programs from accessing the serial
port (i.e., those previous addresses) directly.</p>

<h5>19.1.1.1 Timing issues</h5>

<p>Example programs give the impression of reading and writing from files, but
this can be misleading. Files on the disk are all there at once, and you know
when you have got to the end. Furthermore, if you open a file for reading
and/or writing, you know where you are in the file, and the disk operations
take place in exactly the order you specify. Serial I/O is all about timing.
Consider a port running at 9600 bits per second on a Pentium 400. One byte
arrives every millisecond; your computer can execute more than a hundred
thousand instructions between each byte arriving. Your PC can also wander off
and do something else (load a file, wait for the user, open a Word document or
something) while several bytes arrive at the port unnoticed.</p>

<p>To resolve this, the operating system provides input and output buffers. A
typical size is 1024 bytes. If your program is doing something else, up to 1024
bytes will accumulate and be saved for you, so you don’t have to check the port
continually. If you read from the port, it returns as many bytes as you asked
for from the buffer or nothing if there is no more data. There is no way to
know whether data has finished arriving, or whether more might arrive in
another millisecond; each application needs to define a <i>protocol</i> so that
the application knows whether to wait for more or to stop listening. Protocols
can involve fixed-size transmissions, the use of delimiters such as a carriage
return to say “this message has finished arriving,” or time limits.</p>

<p>If you want to work at a low level, you can use the <tt><span
style='font-size:10.0pt'>CreateFile</span></tt> API call exposed by the Python
Win32 extensions, passing in a filename of “COM1” or “COM2.” You can then read
from and write to this file. Communications functions are well documented in
the MSDN Library. However, for common tasks, there are easier ways to do it.
We’ll look at two of them, using a public domain C-level extension package and
a proprietary COM interface.</p>

<h4>19.1.2 The Serial Module</h4>

<p>Our preferred route for serial I/O with Python is Roger Burnham’s <tt><span
style='font-size:10.0pt'>Serial</span></tt> package. This is free and comes
with an installer and several examples.</p>

<p>The <tt><span style='font-size:10.0pt'>Serial</span></tt> package is based
on a set of serial communications libraries developed by MarshallSoft ( <a
href="http://www.marshallsoft.com" target="_blank">www.marshallsoft.com</a>)
over the last eight years. These libraries are available as a 16- and 32-bit
DLL with identical interfaces, which makes it easy to migrate applications from
16- to 32-bit and back again.<a name="_ftnref17"></a><a href="#_ftn17"><span
class=atitlechar><sup><span style='font-size:9.0pt'>[1]</span></sup></span></a>
The libraries are available as shareware packages for Visual Basic, C, and
Delphi. MarshallSoft have kindly allowed their DLL to be used free of charge as
part of the Python package provided a brief message is included with any
distribution. The core DLL is not Open Source but has been heavily tested and
won several awards.</p>

<p>The <tt><span style='font-size:10.0pt'>Serial</span></tt> package uses SWIG
(see <a href="26.htm#_Chapter_22._Extending_and_Embedding">Chapter 22</a> ) to
create a Python DLL wrapper around the library, and provides easy-to-use Python
wrappers and examples. The Python wrapper class is Open Source and provides a
simple high-level API that simplifies many common communications tasks. The <tt><span
style='font-size:10.0pt'>Serial</span></tt> package provides functions to open
and close serial ports and to read and write from them.</p>

<h5 style='page-break-after:avoid'>19.1.2.1 The art of telephone conversation</h5>

<p>The “Hello, World” of the communications field is to send an <tt><span
style='font-size:10.0pt'>AT</span></tt> command to a modem and get back a
response, so we will take care of this formality first. If you are not familiar
with modems, they almost all speak a common command language defined by Hayes;
the computer sends a line of text beginning with the letters <tt><span
style='font-size:10.0pt'>AT</span></tt> and ending in a carriage return and
linefeed, and the modem sends back a line of text with a response. In
particular, the command <tt><span style='font-size:10.0pt'>ATI</span></tt> asks
a modem to identify itself.</p>

<p>We tried hard to find a way of making this more interesting. Instead of
using a conventional internal or external modem, we decided to make a laptop to
talk to a mobile phone with a built-in modem, via its infrared port. It turned
out that this didn’t involve any special programming at all (IR ports are just
plain old serial ports from the programmer’s viewpoint) but it does far more to
satisfy technolust! The console session below shows a basic conversation with
the modem, which was sitting a few feet away:</p>

<pre>&gt;&gt;&gt; from Serial import Serial</pre><pre>&gt;&gt;&gt; # create a 'configuration dictionary' with the port settings</pre><pre>&gt;&gt;&gt; myconfig = Serial.PortDict()</pre><pre>&gt;&gt;&gt; myconfig['port'] = Serial.COM4</pre><pre>&gt;&gt;&gt; # create and open a port with these settings</pre><pre>&gt;&gt;&gt; myport = Serial.Port(myconfig)</pre><pre>&gt;&gt;&gt; myport.open()</pre><pre>&gt;&gt;&gt; myport.send('ATI\015') #ask modem to identify itself</pre><pre>&gt;&gt;&gt; print myport.read() #get back any response</pre><pre>ATI</pre><pre>&nbsp;</pre><pre>Ericsson SH 888 Infrared Modem</pre><pre>&gt;&gt;&gt; # Python supports Infrared!&nbsp; Cool!</pre>

<p>The <tt><span style='font-size:10.0pt'>Serial</span></tt> package contains
two classes. A <tt><span style='font-size:10.0pt'>PortDict</span></tt> holds
the configuration information needed to begin using a serial port; this comes
with a sensible set of defaults, and is smart enough to check the values you
assign it. If you ask it to display itself at a command prompt, you can see all
the parameters, many of which are self-explanatory:</p>

<pre>&gt;&gt;&gt; myconfig</pre><pre>&lt;Serial Config:</pre><pre>&nbsp;&nbsp; baud = 9600</pre><pre>&nbsp;&nbsp; cmdTerm = ''</pre><pre>&nbsp;&nbsp; cmdsEchoed = 0</pre><pre>&nbsp;&nbsp; dataBits = 8</pre><pre>&nbsp;&nbsp; debug = 0</pre><pre>&nbsp;&nbsp; parity = None</pre><pre>&nbsp;&nbsp; port = COM4</pre><pre>&nbsp;&nbsp; rspFixedLen = 0</pre><pre>&nbsp;&nbsp; rspTerm = ''</pre><pre>&nbsp;&nbsp; rspTermPat = None</pre><pre>&nbsp;&nbsp; rspType = RSP_BEST_EFFORT</pre><pre>&nbsp;&nbsp; rxBufSize = 1024</pre><pre>&nbsp;&nbsp; stopBits = 1</pre><pre>&nbsp;&nbsp; timeOutMs = 500</pre><pre>&nbsp;&nbsp; txBufSize = 1024</pre><pre>&gt;</pre><pre>&nbsp;</pre><pre>&gt;&gt;&gt;</pre>

<p>This is passed as an argument to the constructor of a <tt><span
style='font-size:10.0pt'>Port</span></tt> object, which manages the
conversation. You’ve just seen the key methods of a Port object: <tt><span
style='font-size:10.0pt'>open()</span></tt>, <tt><span style='font-size:10.0pt'>read()</span></tt>,
<tt><span style='font-size:10.0pt'>write()</span></tt>, and <tt><span
style='font-size:10.0pt'>close()</span></tt>. We relate what they do in more
detail later.</p>

<p>The most widely available serial devices are mice and modems; however, there
is not much likelihood you will need to write a driver for either, so we’ll
look instead at some laboratory instruments that together illustrate some key
principles. The first stage in talking to any remote device is to learn about
its communications protocol and think through the timing issues involved.</p>

<p>Andy maintains a data-analysis package for two devices called the <i>Mark
III</i> and <i>Mark IV GastrograpH</i>, made by Medical Instruments Corporation
of Switzerland. These are used to diagnose chronic stomach pain; patients have
a probe inserted into their stomachs, and carry a small battery-powered device
for 24 hours that captures the pH values, as well as user-input information
about meals, sleep and pain. At the end of the 24-hour period, the data is
downloaded to a PC. Fortunately it comes with a test signal generator, which
removed the need to self-intubate while writing this chapter!</p>

<h5>19.1.2.2 The Mark III: Reading large amounts of data</h5>

<p>The Mark III GastrograpH is a very simple instrument from a communication
viewpoint. You press a transmit button, and it sends a fixed-size block of data
(essentially dumping the contents of its RAM). It neither knows nor cares if
there is a PC listening at the far end.</p>

<p>The port settings are 9600 baud, eight data bits, one stop bit, and no
parity. One byte of data thus needs 9 bits (8 data + 1 stop), so you can expect
about 1067 bytes per second (9600 / (8+1)) or one per millisecond. The device
sends a header of 22 bytes, followed by 24 separate blocks of 4102 bytes each
(each of these is 4 KB of RAM plus a few checksums), totaling exactly 98,470
bytes. Between each block there is a 200ms pause. The whole download takes
about 97 seconds.</p>

<p>Let’s use the <tt><span style='font-size:10.0pt'>Serial</span></tt> class to
capture this data. The <tt><span style='font-size:10.0pt'>read()</span></tt>
method we saw earlier is actually extremely flexible; the full header is <tt><span
style='font-size:10.0pt'>read(<i>cnt=None,</i></span></tt> <tt><i><span
style='font-size:10.0pt'>timed= FALSE</span></i></tt>). When you initialize a <tt><span
style='font-size:10.0pt'>Serial</span></tt> class instance, you specify a
timeout, which has a default value of half a second. The read method can be
used in three totally different ways:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><tt><span style='font-size:10.0pt'>MySerialPort.read()</span></tt> returns
any data that has arrived at the serial port since you last called <tt><span
style='font-size:10.0pt'>read()</span></tt> or since it was opened. The data is
returned as a string.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><tt><span style='font-size:10.0pt'>MySerialPort.read(1024)</span></tt>
reads 1024 bytes from the serial port, waiting all night if necessary.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><tt><span style='font-size:10.0pt'>MySerialPort.read(1024,</span></tt> <tt><span
style='font-size:10.0pt'>timed=1)</span></tt> reads 1024 bytes from the serial
port, or raise an error if that many bytes haven’t arrived before the timeout
limit. The default timeout is half a second, which is ample time to receive
short responses from most devices. You can specify a timeout of up to 60
seconds when initializing a port.</p>

<p>The first approach that occurred to us was to change one line of <i>Serial.py</i>
to allow a two-minute timeout and read the whole lot in one command. That
works, but is not desperately user-friendly; if the device isn’t transmitting,
you still have to wait two minutes to find out. Instead, we grabbed it in a
number of chunks matching the device protocol itself. Each takes about four
seconds to arrive, so set a timeout of 10 seconds. This should be long enough
for the user to start Python listening, then hit the Transmit button on the
device. Here’s the capture function:</p>

<pre>from Serial import Serial</pre><pre>import traceback</pre><pre>import string</pre><pre>&nbsp;</pre><pre>def captureMark3Data(port=Serial.COM3):</pre><pre>&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;#fill a config dictionary with the settings we want</pre><pre>&nbsp;&nbsp;&nbsp; cfg = Serial.PortDict()</pre><pre>&nbsp;&nbsp;&nbsp; cfg['port'] = port</pre><pre>&nbsp;&nbsp;&nbsp; cfg['baud'] = Serial.Baud9600</pre><pre>&nbsp;&nbsp;&nbsp; cfg['parity'] = Serial.NoParity</pre><pre>&nbsp;&nbsp;&nbsp; cfg['stopBits'] = Serial.OneStopBit</pre><pre>&nbsp;&nbsp;&nbsp; cfg['timeOutMs'] = 10000&nbsp;&nbsp; # ten seconds</pre><pre>&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;# create a Port object based on these settings</pre><pre>&nbsp;&nbsp;&nbsp; prt = Serial.Port(cfg)</pre><pre>&nbsp;&nbsp;&nbsp; prt.open()</pre><pre>&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;print 'Port open...'</pre><pre>&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;blocks = []</pre><pre>&nbsp;&nbsp;&nbsp; #read some data</pre><pre>&nbsp;&nbsp;&nbsp; try:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # first section is 22 bytes, followed by a pause</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = prt.read(22,timed=1)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocks.append(header)</pre><pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'read header'</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# followed by 24 blocks of 4102 bytes, and pauses</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(24):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block = prt.read(4102, timed=1)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocks.append(block)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'read block',i,'of 24'</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prt.close()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alldata = string.join(blocks, '')</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return alldata</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;except:&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# close the port but print the error message</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prt.close()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; traceback.print_exc()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None</pre>

<p>Note that a <tt><span style='font-size:10.0pt'>try...except...</span></tt>
handler was used to ensure that the port is always closed. Leaving a COM port
open prevents other programs (or your own) from using it for some time; on
Windows 95, this can persist until a reboot.</p>

<p>The first thing to do is try running the function without even connecting
the GastrograpH<i> </i>to the port. This results in a timeout error after ten
seconds, which is handled gracefully:</p>

<pre>&gt;&gt;&gt; import commdemos</pre><pre>&gt;&gt;&gt; data = commdemos.captureMark3Data()</pre><pre>Port open...</pre><pre>Traceback (innermost last):</pre><pre>&nbsp; File &quot;C:\Data\Project\OReilly\chXX_Communications\examples\</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commdemos.py&quot;, line 30, in captureMark3Data</pre><pre>&nbsp;&nbsp;&nbsp; header = prt.read(22,timed=1)</pre><pre>&nbsp; File &quot;C:\Program Files\Python\Serial\Serial.py&quot;, line 456, in read</pre><pre>&nbsp;&nbsp;&nbsp; raise SioError, \</pre><pre>SioError: Timed out waiting for input chr 0 of 22, read ''.</pre><pre>&gt;&gt;&gt;</pre>

<p>Having done that, you can try it for real. Call the function; then press
Transmit:</p>

<pre>&gt;&gt;&gt; import commdemos</pre><pre>&gt;&gt;&gt; data = commdemos.captureMark3Data()</pre><pre>Port open...</pre><pre>read header, blocks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17&nbsp; \</pre><pre>18 19 20 21 22 23 24 ..done!</pre><pre>&gt;&gt;&gt; len(data)</pre><pre>98470</pre><pre>&gt;&gt;&gt; data[0:10]</pre><pre>'\000\000\020\000HK\030\000\001\002'</pre><pre>&gt;&gt;&gt;</pre>

<h5>19.1.2.3 The Mark IV and dialogs</h5>

<p>The Mark III downloaded its whole memory. Capturing data was trivial;
deciphering it was a lot of work. The Mark IV GastrograpH, which replaces the
Mark III, communicates in a different way and aims to return meaningful
information. The protocol is simple: you send one byte, and it replies with
another in three to four milliseconds. There are about 20 separate requests you
can make; one request returns start date information, another returns the next
byte in a time series, and so on. This is another common serial programming
paradigm; you send a short sequence and get something back promptly. This
enables us to talk to the device at the command prompt. Note that you need to
specify <tt><span style='font-size:10.0pt'>timed=1</span></tt> so that Python
waits for a response; otherwise, it reads an empty string from the port long
before the device has time to respond.</p>

<p>The <tt><span style='font-size:10.0pt'>Serial.Port</span></tt> class has a
method to send a command and get a response that is highly configurable, but
doesn’t do quite what you want. Let’s make a subclass that has a method to
carry out the kind of dialog we want:</p>

<pre>class Mark4Port(Serial.Port):</pre><pre>&nbsp;&nbsp;&nbsp; def talk(self, byte):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #send a byte, wait up to 500ms for one byte back</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.write(chr(byte))</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resp = self.read(cnt=1,timed=1)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ord(resp[0])</pre>

<p>The needed dialog requires only one three-line method. Armed with this, you
can talk to the device on the command prompt in real time:</p>

<pre>&gt;&gt;&gt; from Serial import Serial</pre><pre>&gt;&gt;&gt; cfg = Serial.PortDict()</pre><pre>&gt;&gt;&gt; cfg['baud']=Serial.Baud19200</pre><pre>&gt;&gt;&gt; cfg['port']=Serial.COM3</pre><pre>&gt;&gt;&gt; M4 = commdemos.Mark4Port(cfg)</pre><pre>&gt;&gt;&gt; M4.open()</pre><pre>&gt;&gt;&gt; M4.talk(2)&nbsp;&nbsp;&nbsp;&nbsp; # how many hours recording planned?</pre><pre>24</pre><pre>&gt;&gt;&gt; M4.talk(10)&nbsp;&nbsp;&nbsp; # how many hours took place?</pre><pre>0</pre><pre>&gt;&gt;&gt; M4.talk(9)&nbsp;&nbsp;&nbsp;&nbsp; # how many minutes took place?</pre><pre>10</pre><pre>&gt;&gt;&gt; M4.close()</pre><pre>&gt;&gt;&gt;</pre>

<p>When you have limited documentation, the ability to interrogate a device in
interactive mode like this is a real help.</p>

<h5>19.1.2.4 Of mice and modems</h5>

<p>Naturally, you won’t have either of these devices available, but there are
two things you can play with quite easily: serial mice and modems. With a
mouse, all you need is a loop that listens to the port and displays the bytes
that are generated whenever you move it. Furthermore, if you look around, a
growing number of peripherals and palmtop computers offer infrared ports, and
it can be fun (and potentially even useful) to attempt to talk to them. </p>

<h4>19.1.3 The Microsoft Communications Control (MSComm)</h4>

<p>Microsoft has provided a COM interface to the serial port in the form of an
OCX. This gives less detailed control than the Python <tt><span
style='font-size:10.0pt'>Serial</span></tt> package, but is adequate for the
kind of examples above. It’s distributed with Visual Basic, Visual Studio, and
most Microsoft development tools; you need one of these packages to
redistribute it. In a corporate setting this isn’t usually a problem. Unlike
the <tt><span style='font-size:10.0pt'>Serial</span></tt> package, it requires
the Python COM framework. Let’s talk to a modem with it, this time reverting to
a plain old system connected with real wires:</p>

<pre>def MSCommDemo():</pre><pre>&nbsp;&nbsp;&nbsp; #talks to a modem on COM1</pre><pre>&nbsp;&nbsp;&nbsp; from win32com.client import Dispatch</pre><pre>&nbsp;&nbsp;&nbsp; comm = Dispatch('MSCOMMLib.MSComm')</pre><pre>&nbsp;&nbsp;&nbsp; comm.CommPort = 1&nbsp;&nbsp;&nbsp; #COM1</pre><pre>&nbsp;&nbsp;&nbsp; comm.PortOpen = 1</pre><pre>&nbsp;&nbsp;&nbsp; try:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comm.Output = &quot;AT\015&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # add a carriage return</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inbuf = ''</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = time.time()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elapsed = time.time() - now</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (string.find(inbuf, 'OK') &lt; 0) and (elapsed &lt; 2):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inbuf = inbuf + str(comm.Input)&nbsp; #remember the Unicode string!</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elapsed = time.time() - now</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print inbuf</pre><pre>&nbsp;&nbsp;&nbsp; finally:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comm.PortOpen = 0</pre>

<p>When run, you should see your command of <tt><span style='font-size:10.0pt'>AT</span></tt>
echoed, followed by the response <tt><span style='font-size:10.0pt'>OK</span></tt>.
Note that you don’t know how long it will take to respond, so you loop until
you get the desired data or until some time limit has elapsed. This behavior
was wrapped for us by <i>Serial.py</i>, and you could wrap it here as well if
you were going to use the <tt><span style='font-size:10.0pt'>MSComm</span></tt>
control a lot.</p>

<p>One truly amazing thing about the <tt><span style='font-size:10.0pt'>MSComm</span></tt>
control is the syntax. Microsoft loves properties; we saw that the Excel and
Word object models used property assignments for lots of things, but this
control takes it to new limits. <tt><span style='font-size:10.0pt'>MSComm</span></tt>
has no—count ‘em—no methods. One major reason for using properties is that they
can be set at design time in the Visual Basic development environment, but the
key properties are runtime only. You can argue that a <tt><span
style='font-size:10.0pt'>PortOpen</span></tt> property has its uses; you can at
least query it. Assigning a string to a write-only <tt><span style='font-size:
10.0pt'>Input</span></tt> property, instead of providing a <tt><span
style='font-size:10.0pt'>Write()</span></tt> method, is weird. Getting a return
value from an <tt><span style='font-size:10.0pt'>Output</span></tt> property,
and being able to ask for it only once, is even less natural. We can’t see any
design rationale behind this. Nevertheless, it works. </p>

<h3><a name="_19.2_Remote_Access_Services"></a>19.2 Remote Access Services</h3>

<p>There is no real need to talk to modems these days, because Windows provides
a standard set of dialogs and APIs for making and breaking dial-up connections.
These are collectively known as Remote Access Services, or RAS for short. Users
can create and save connections that specify many things, including the number
to dial, usernames and passwords, and network protocols and settings.</p>

<p>The dialogues vary considerably between Windows 95, 98, and NT, but the
principles under the hood are the same. Windows thinks in terms of a phonebook.
NT can have many phonebooks, stored in files with extension PBK; on Windows 95
and 98 there is a single default phonebook. The machine in <a
href="#_Figure_19.1._Dial-Up_Networking_fol">Figure 19.1</a> has three entries.</p>

<h5 align=center style='text-align:center'><a
name="_Figure_19.1._Dial-Up_Networking_fol"></a>Figure 19.1. Dial-Up Networking
folder in Windows 98</h5>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-family:Arial'><img border=0 width=502 height=143
src="images\image062.gif" alt="figs/ppw.1901.gif"></span></p>

<p>The <tt><span style='font-size:10.0pt'>win32ras</span></tt> module supplied
with PythonWin provides a number of functions to manipulate these. <tt><span
style='font-size:10.0pt'>EnumEntries()</span></tt> returns a list of tuples
with the names of the entries in the phonebook:</p>

<pre>&gt;&gt;&gt; import win32ras</pre><pre>&gt;&gt;&gt; win32ras.EnumEntries()&nbsp;&nbsp; # what is in the phonebook?</pre><pre>[('Assi Modem Pool',), ('Demon',), ('Demon Private',)]</pre><pre>&gt;&gt;&gt; win32ras.EnumConnections()&nbsp; # show what's active now</pre><pre>[]</pre><pre>&gt;&gt;&gt;</pre>

<p>To make a connection, you need to specify a tuple of up to six strings. This
matches the <tt><span style='font-size:10.0pt'>RASDIALPARAMS</span></tt>
structure in Windows. The values are:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Entry name</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Phone number</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Callback number (used if you are dialing an NT server configured to call
you right back)</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Username for the remote network</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Password for the remote network</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Domain name for the remote network (only for NT)</p>

<p>You can obtain such a list from an existing phonebook entry with the <tt><span
style='font-size:10.0pt'>GetEntryDialParams(</span></tt><i>PhoneBook,</i> <i>EntryName</i><tt><span
style='font-size:10.0pt'>)</span></tt> function. This displays some entries but
hides passwords for obvious reasons:</p>

<pre>&gt;&gt;&gt; params = win32ras.GetEntryDialParams(None, 'Demon Internet')</pre><pre>&gt;&gt;&gt; params</pre><pre>(('Demon Internet', '', '', 'username', '', ''), None)</pre>

<p>However, in most cases you just want to make a call, so you can provide the
attributes you need yourself. Let’s dial up an Internet provider, specifying
the name of the phonebook entry to use:</p>

<pre>&gt;&gt;&gt; import win32ras</pre><pre>&gt;&gt;&gt; myParams = ('Demon Internet','0845-3535666','',&nbsp; \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'username','password','')</pre><pre>&gt;&gt;&gt; (hras, success) = win32ras.Dial(None, None, myParams, None)</pre><pre>&gt;&gt;&gt; # do your stuff on the network now</pre><pre>&gt;&gt;&gt; win32ras.HangUp(hras)</pre><pre>&gt;&gt;&gt;</pre>

<p>When you hit Return after <tt><span style='font-size:10.0pt'>Dial</span></tt>,
Windows goes through its usual connection procedure, and control is returned to
Python only after a connection is made or an error has occurred. If <tt><span
style='font-size:10.0pt'>success</span></tt> is zero or greater, you can assume
the connection works.</p>

<p>It’s also possible to supply a callback function as the fourth argument to
the <tt><span style='font-size:10.0pt'>Dial()</span></tt> function; this is
called whenever a RAS event occurs, such as a successful connection, the line
being dropped, or an error. See the <tt><span style='font-size:10.0pt'>win32ras</span></tt>
documentation in the PythonWin help file for more details.</p>

<p>A typical use for RAS would be writing a script to connect at various times
of the day, and conversely to ensure that connections are brought down again
after a certain amount of time. What you can do when you get connected depends
on the type of network, which is most easily specified in the various dialogs
for the phonebook entry. If dialing into a corporate NT network, you could
begin mapping network drives after connecting; with a TCP/IP network, you can
start using Python’s many TCP/IP libraries to automate web, email and FTP
operations. </p>

<h3><a name="_19.3_Sockets"></a>19.3 Sockets</h3>

<p>Our third and final topic under the theme of communications is the Sockets
API. This is the programmer’s interface to the TCP/IP protocol itself. Sockets
are supported by all major operating systems, via a standard C-level interface.
This interface is available in Python on all platforms, enabling you to write
custom communications protocols. <a
href="19.htm#_Chapter_15._Using_the_Basic_Interne">Chapter 15</a>, describes a
number of Python library modules that implement the standard protocols. The
Python standard library contains many examples of how to write applications
using sockets.</p>

<p>The key concepts bear some similarity to the serial communications we saw
earlier: there is a file-like interface that permits reading and writing, and
the same issue of not knowing when a transmission has finished. However, you
can’t guarantee a response in a given timeframe, and indeed responses on the
Internet can vary widely from fractions of a second up to several seconds.</p>

<p>Sockets are great fun to experiment with, particularly in Python, where the
client socket can be scripted from an interactive console session. Ideally you
need two computers close to each other on the same TCP/IP network; however, one
machine works fine as long as it has TCP/IP installed. Sockets can communicate
between processes on the same machine.</p>

<h4>19.3.1 A Simple Socket Server</h4>

<p>The following function implements a short socket server:</p>

<pre># socketserver1.py - runs forever,</pre><pre># reverse each message received.</pre><pre>from socket import *</pre><pre>import string</pre><pre>&nbsp;</pre><pre>HOST = ''&nbsp;&nbsp;&nbsp;&nbsp; # this means local</pre><pre>PORT = 8578&nbsp;&nbsp; #arbitrary, high number</pre><pre>&nbsp;</pre><pre>def serve():</pre><pre>&nbsp;&nbsp;&nbsp; # this reverses each message received, lasts forever</pre><pre>&nbsp;&nbsp;&nbsp; serversock = socket(AF_INET, SOCK_STREAM)</pre><pre>&nbsp;&nbsp;&nbsp; serversock.bind((HOST, PORT))</pre><pre>&nbsp;&nbsp;&nbsp; serversock.listen(1)&nbsp;&nbsp; # max bcklog of 1-5 connections</pre><pre>&nbsp;&nbsp;&nbsp; print 'socket listening for connections...'</pre><pre>&nbsp;&nbsp;&nbsp; while 1:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlersock, addr = serversock.accept()&nbsp; </pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # now do something with the handler socket</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'handler connected by', addr</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = handlersock.recv(1024)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'received', data</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlersock.send(string.upper(data))</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handlersock.close()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'handler closed'</pre><pre>&nbsp;</pre><pre>if __name__ == '__main__':</pre><pre>&nbsp;&nbsp;&nbsp; serve()</pre>

<p>You can start this server by running it from a DOS prompt. Let’s step
through a line at a time:</p>

<p class=MsoNormal><span class=monofont1><span style='color:#990000'>serversock
= socket(AF_INET, SOCK_STREAM)</span></span><span style='font-family:Arial;
color:#990000'> </span></p>

<p style='margin-left:.5in'>This creates the server socket. Don’t worry about
the constants; there are other types of sockets, but their use is unusual and
definitely out of scope for this chapter.</p>

<p class=MsoNormal><span class=monofont1><span style='color:#990000'>serversock.bind(HOST,
PORT)</span></span><span style='font-family:Arial;color:#990000'> </span></p>

<p style='margin-left:.5in'>This associates the socket with a TCP/IP hostname
and port number. An empty string, the hostname (if you know it), or the result
of the function <tt><span style='font-size:10.0pt'>gethostname()</span></tt>
all mean the local machine. <tt><span style='font-size:10.0pt'>PORT</span></tt>
is a number between and 65535 and can be thought of like a radio channel or
telephone line. The lower port numbers are used for standard services, so pick
a big one.</p>

<p class=MsoNormal><span class=monofont1><span style='color:#990000'>serversock.listen(1)</span></span><span
style='font-family:Arial;color:#990000'> </span></p>

<p style='margin-left:.5in'>This places the socket in a passive state and specifies
a backlog of connections. We have told it that only one connection at a time is
allowed; you can specify up to five. For socket applications use short-lived
connections, this is usually plenty; the network buffers requests from
subsequent sockets so that the server only has to deal with one at a time.</p>

<p>We now go into a loop. The server socket runs until you kill the process.
The next line is where the action happens:</p>

<p class=MsoNormal><span class=monofont1><span style='color:#990000'>handlersock,
addr = serversock.accept()</span></span><span style='font-family:Arial;
color:#990000'> </span></p>

<p style='margin-left:.5in'>At this point the program waits until a connection
is received from a <i>client socket</i> somewhere else on the network. This
could be some time. We’ll look at the client side in a moment. When a client
does connect, the network software creates a totally new socket, which we will
call a <i>handler socket</i>. We are also passed the address of the socket on
the far end of the connection. The handler socket is a totally different beast
from the server socket; in some ways it’s a pity they are implemented as the
same object. In fact, it’s identical to the client socket we will look at in a
moment. The two are welded together, with the input of one hooked up to the
output of the other. They are also communicating on another network port to the
one we originally specified, something assigned randomly by TCP/IP. The original
server socket can continue listening on the specified port.</p>

<p>At this point, it doesn’t really matter what the client and handler sockets
do. The server socket has handled the request, the incoming port is free, and it’s
now free (in theory) to handle the next incoming request. A more complex server
than ours might actually set up a separate thread to handle the request.</p>

<p>Now let’s pop over to the client side and see what is going on there. We’ve
implemented the client side of the conversation from a console session:</p>

<pre>[CLIENT]</pre><pre>&gt;&gt;&gt; from socket import *</pre><pre>&gt;&gt;&gt; clientsock = socket(AF_INET, SOCK_STREAM)</pre><pre>&gt;&gt;&gt; clientsock.connect('tahoe',8578)</pre><pre>&gt;&gt;&gt;</pre>

<p>The <tt><span style='font-size:10.0pt'>connect method</span></tt> can take
the name of the machine or the IP address (represented as the usual dotted
string), or <tt><span style='font-size:10.0pt'>&quot;localhost&quot;</span></tt>
if you are talking to yourself on one machine. If you don’t get an error
message, you’re connected. Now let’s look back at the console for the server:</p>

<pre>[SERVER]</pre><pre>D:\Examples\Comms&gt;python socketserver1.py</pre><pre>socket listening for connections...</pre><pre>handler connected by ('192.42.172.3', 1029)</pre>

<p>This identifies the machine from which the connection arrived, and the port
on which the client socket and handler socket are now talking.</p>

<p>The client is in position to send requests to the handler socket and hold a
conversation. We’ve provided a simplistic example; the client sends a short
string, and the server sends it back in uppercase. After one such exchange, the
two sockets close. This is dangerously simplistic (we’ll discover why later).
Now they can talk; it’s back to the client side:</p>

<pre>&gt;&gt;&gt; clientsock.send('hello')&nbsp;&nbsp;&nbsp; # returns bytes sent</pre><pre>5</pre><pre>&gt;&gt;&gt; clientsock.recv(1024)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # max bytes to receive</pre><pre>'HELLO'</pre><pre>&gt;&gt;&gt; clientsock.close()</pre><pre>&gt;&gt;&gt;</pre>

<p>The conversation is over, and the server socket is now ready to accept and
process the next request. It’s essential to close down sockets when finished by
calling the <tt><span style='font-size:10.0pt'>close()</span></tt> method. This
notifies the remote socket that no more data will be sent. If your program
fails to close a socket cleanly, the one at the far end of the connection may
hang indefinitely.</p>

<h4>19.3.2 Communication Between Sockets</h4>

<p>The previous example covered the key features of how sockets get connected,
but was dangerously simple. We sent a very short string, then waited a couple
of seconds while we typed the call to receive a response. We got back the
expected data, but were lucky: in real life, there’s more to worry about.</p>

<p>The <tt><span style='font-size:10.0pt'>send()</span></tt> call doesn’t
instantly send a string, however long. It tries to send the string and returns
the number of bytes sent. With a big string (e.g., a file-transfer application)
or in bad network conditions, the <tt><span style='font-size:10.0pt'>send()</span></tt>
call sends only a small part on each call. It might also return zero, which
indicates that the network connection has been broken. The only safe way to
send a string is to do it in a loop and check the return values to see what has
actually been sent. Here’s a function to send an arbitrary string safely:</p>

<pre># this sends strings over sockets more safely</pre><pre>def safeSend(sock, message):</pre><pre>&nbsp;&nbsp;&nbsp; msglen = len(message)</pre><pre>&nbsp;&nbsp;&nbsp; totalsent = 0</pre><pre>&nbsp;&nbsp;&nbsp; while totalsent &lt; msglen:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sent = sock.send(msg[totalsent:])</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if sent == 0:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise RuntimeError, 'connection broken'</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalsent = totalsent + sent</pre>

<p>At this point you’ve hit a fundamental problem. There is no way for the
receiving socket to know how much data to expect, nor whether a message has
finished arriving. You have to design your protocol so that client and handler
know what to expect at every stage. There are several schemes for doing this:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Always use fixed-size messages.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Add a final delimiter.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Indicate how long messages are.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Send once and shut down. The receiving socket loops until it receives a
zero and knows it’s done.</p>

<p>One effective scheme is to make the first byte of each message a code
indicating the type of message and to have a standard length for each message
type, padding messages if needed. Another is to send a fixed-length message on
the first exchange and include in each exchange the length of the subsequent
message. Once you’ve designed a protocol, you can write a <tt><span
style='font-size:10.0pt'>safeReceive</span></tt> procedure to match it and
ensure you get all of the data. Note that you can send binary data safely over
sockets.</p>

<h4>19.3.3 Where to Go from Here</h4>

<p>The design here works for short-lived connections and low traffic. If you
want to handle multiple simultaneous requests, there are several different
strategies, but they all involve quite a bit of work. One option is to create
separate threads to handle each request (look in the <tt><span
style='font-size:10.0pt'>thread</span></tt> and <tt><span style='font-size:
10.0pt'>threading</span></tt> modules in the Python Library Reference). Another
is to use nonblocking sockets and the <tt><span style='font-size:10.0pt'>select</span></tt><i>
</i>statement, which looks at a bunch of sockets and tells you which have data
ready to read or are ready to accept outgoing data.<a name="_ftnref18"></a><a
href="#_ftn18"><span class=atitlechar><sup><span style='font-size:9.0pt'>[2]</span></sup></span></a></p>

<p>We won’t go any further into building sockets applications here. We’ve gone
about as far as we can simply, and it gets more complex from here on.</p>

<p>Fortunately the work has been done for you. The Python standard library
module <i>socketserver.py</i> provides an extremely useful generic server
architecture. It includes a generic server class that you might or might not
need to subclass and a request-handler class you definitely want to override.
This is an excellent place to go next. Several other standard library modules
define web servers based on the standard socket server.</p>

<p>We hope we have made it clear that sockets programming is not only feasible
but also straightforward on Python. It’s comparatively rare to need to develop
your own socket-based protocols, and if you do need to do it, you will know far
more about the subject than we can cover here.</p>

<p>World-class networking software has been developed in Python; examples
include the Infoseek search engine, Zope, and Medusa . Zope and Medusa are
discussed briefly in <a href="5.htm#_Chapter_3._Python_on_Windows">Chapter 3</a>.</p>

<h3><a name="_19.4_Other_Communications_Tools"></a>19.4 Other Communications
Tools</h3>

<h4>19.4.1 Named Pipes</h4>

<p>We ought to quickly mention named pipes again. These are a Microsoft
technology similar to sockets and have been part of Windows NT since its
inception. As with sockets and serial ports, you read and write to named pipes.
You open them by passing a suitable network path to <tt><span style='font-size:
10.0pt'>CreateFile</span></tt> of the form <i>\\mymachine\pipe\mypipe</i>.
Named pipes function over whatever network protocol NT is using; it might be
TCP/IP, IPX, or NetBEUI. On Windows, they operate slightly faster than sockets
and can also be secured. They are extensively used by Microsoft’s networking
APIs and back office products.</p>

<p>About the only reason to use named pipes is for their integrated security.
Named pipes are fully securable by Windows NT, and you can rely on Windows
reporting a valid and authenticated user at the other end of the pipe. For most
communications applications that don’t have a high requirement for security,
sockets are often simpler to use, and have the added advantage of being
cross-platform.</p>

<h4>19.4.2 Remote Procedure Call (RPC)</h4>

<p>RPC is a communications technology originally developed by the DCE
consortium. It builds on top of a network protocol such as TCP/IP to provide
the ability to call functions on remote machines. When you design a
client/server socket application, you work hard to get to the point where you can
send a request to a remote object and get a response reliably. In our case,
what we wanted was a remote function to reverse strings, not a load of
messages. RPC handles all this, and is supported by Windows. It lets you build
tightly coupled client and server applications.</p>

<p>On Windows, Distributed COM (which builds on top of RPC) has made the RPC
programming interface pretty much obsolete. Python supports DCOM rather than
RPC. For details, see <a href="16.htm#_Chapter_12._Advanced_Python_and_COM">Chapter
12</a>.</p>

<h3><a name="_19.5_Conclusion"></a>19.5 Conclusion</h3>

<p>Python provides excellent supports for communications tasks of all kinds,
including serial I/O and network programming. While the concepts and interfaces
in Python are similar to those in C, Python is very successful at hiding a lot
of the mess you deal with working at the C level, and lets you concentrate on
the problem. Since communications channels generally run much slower than the
host PCs, there is no need to work at a lower level.</p>

<h3><a name="_19.6_References"></a>19.6 References</h3>

<p>If you want to work with serial communications at a low level on Windows NT,
there is some information in MSDN Library under <i>Platform SDK/Windows Base
Services/Files and IO/Communications</i>.</p>

<p>MarshallSoft, <a href="http://www.marshallsoft.com/" target="_blank">http://www.marshallsoft.com/</a>,
makes the libraries underpinning the <tt><span style='font-size:10.0pt'>Serial</span></tt>
package; evaluation libraries are available for download, as are numerous
example programs in various languages.</p>

<p>Gordon McMillan has written a sockets how-to guide that can be found at <a
href="http://www.python.org" target="_blank">www.python.org</a>. Much of the
information in this section was based on his guide.</p>

<p class=MsoFootnoteText><a name="_ftn17"></a><a
href="23.htm#_ftnref17" title=""><span
class=MsoFootnoteReference>[1]</span></a> <span style='font-size:7.5pt'>It
would be nice to think 16-bit Windows was dead in 1999, but you would be amazed
how many cash-strapped hospitals and university laboratories still have old
Windows 3.1 PCs collecting data.</span></p>

<p class=MsoFootnoteText><a name="_ftn18"></a><a
href="23.htm#_ftnref18" title=""><span
class=MsoFootnoteReference>[2]</span></a> <span style='font-size:7.5pt'>Note
that on Unix, </span><tt>select()</tt><span style='font-size:7.5pt'> can work
with file descriptors as well as sockets; on Windows, it works only with
sockets.</span></p>

<p class=MsoNormal>&nbsp;</p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%;background:#ECECD9;border-collapse:collapse;border:none'>
 <tr>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="22.htm"><span style='text-decoration:none'><img
  border=0 width=37 height=34 src="leftarrw.gif"></span></a></p>
  </td>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><a href="0.htm"><span
  style='font-size:13.5pt'>Table of Contents</span></a></p>
  </td>
  <td width="34%" style='width:34.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=right style='text-align:right'><a href="24.htm"><span
  style='text-decoration:none'><img border=0 width=37 height=34
  src="rightarrw.gif"></span></a></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

</div>

</body>

</html>
