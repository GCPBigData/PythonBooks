<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 10 (filtered)">
<title> </title>

<link rel=Stylesheet type="text/css" media=all href="1.css">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
h1
	{margin-top:1.0in;
	margin-right:0in;
	margin-bottom:.5in;
	margin-left:0in;
	text-align:center;
	page-break-before:always;
	font-size:24.0pt;
	font-weight:bold;}
h2
	{page-break-before:always;
	font-size:18.0pt;
	font-weight:bold;}
h3
	{font-size:13.5pt;
	font-weight:bold;}
h4
	{font-size:12.0pt;
	font-weight:bold;}
h5
	{font-size:10.0pt;
	font-weight:bold;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{font-size:12.0pt;
	font-weight:bold;}
p.MsoBodyText3, li.MsoBodyText3, div.MsoBodyText3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	font-size:8.0pt;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin:0in;
	margin-bottom:.0001pt;
	background:navy;
	font-size:12.0pt;}
p
	{font-size:12.0pt;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;}
p.footnote, li.footnote, div.footnote
	{font-size:12.0pt;}
p.monofont, li.monofont, div.monofont
	{font-size:12.0pt;}
p.romanfont, li.romanfont, div.romanfont
	{font-size:12.0pt;}
p.atitle, li.atitle, div.atitle
	{font-size:9.0pt;
	font-weight:bold;}
p.chaptertitle, li.chaptertitle, div.chaptertitle
	{margin-top:0in;
	margin-right:7.5pt;
	margin-bottom:0in;
	margin-left:7.5pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
p.sectiontitle, li.sectiontitle, div.sectiontitle
	{margin-top:0in;
	margin-right:15.0pt;
	margin-bottom:0in;
	margin-left:15.0pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;}
p.itable, li.itable, div.itable
	{font-size:12.0pt;}
p.tiny, li.tiny, div.tiny
	{font-size:7.0pt;}
p.multiselect, li.multiselect, div.multiselect
	{font-size:7.5pt;}
p.safnavoff, li.safnavoff, div.safnavoff
	{font-size:8.5pt;}
p.safnavon, li.safnavon, div.safnavon
	{font-size:8.5pt;
	font-weight:bold;}
p.navtopbg, li.navtopbg, div.navtopbg
	{background:#990000;
	font-size:12.0pt;}
p.navleftbg, li.navleftbg, div.navleftbg
	{background:#666666;
	font-size:12.0pt;}
p.navleftbgalt, li.navleftbgalt, div.navleftbgalt
	{background:#666666;
	font-size:12.0pt;}
p.navtitle, li.navtitle, div.navtitle
	{font-size:9.0pt;
	font-weight:bold;}
p.nonavtitle, li.nonavtitle, div.nonavtitle
	{font-size:9.0pt;
	font-weight:bold;}
p.bimodoff, li.bimodoff, div.bimodoff
	{font-size:12.0pt;}
p.bimodon, li.bimodon, div.bimodon
	{font-size:12.0pt;}
p.btblinks, li.btblinks, div.btblinks
	{font-size:8.5pt;}
p.btlinksactive, li.btlinksactive, div.btlinksactive
	{font-size:12.0pt;
	font-weight:bold;}
p.inputtext, li.inputtext, div.inputtext
	{font-size:12.0pt;}
p.inputbutton, li.inputbutton, div.inputbutton
	{font-size:12.0pt;
	font-weight:bold;}
p.endsearch, li.endsearch, div.endsearch
	{font-size:12.0pt;
	font-weight:bold;}
p.dropdown, li.dropdown, div.dropdown
	{font-size:12.0pt;}
p.navtoptoolbg, li.navtoptoolbg, div.navtoptoolbg
	{background:black;
	font-size:12.0pt;}
p.headingbarbg, li.headingbarbg, div.headingbarbg
	{background:#333333;
	font-size:12.0pt;}
p.headingsubbarbg, li.headingsubbarbg, div.headingsubbarbg
	{background:#CCCCCC;
	font-size:12.0pt;}
p.headingbartitle, li.headingbartitle, div.headingbartitle
	{font-size:10.5pt;
	font-weight:bold;}
p.headingsubbartitle, li.headingsubbartitle, div.headingsubbartitle
	{font-size:9.0pt;
	font-weight:bold;}
p.tablestripe, li.tablestripe, div.tablestripe
	{background:#EEEEEE;
	font-size:12.0pt;}
p.pgtitle, li.pgtitle, div.pgtitle
	{font-size:12.0pt;
	font-weight:bold;}
p.buyprint, li.buyprint, div.buyprint
	{font-size:7.5pt;}
p.resulthighlight, li.resulthighlight, div.resulthighlight
	{background:lightblue;
	font-size:12.0pt;}
p.pgsubtitle, li.pgsubtitle, div.pgsubtitle
	{font-size:12.0pt;
	font-weight:bold;}
p.helphead, li.helphead, div.helphead
	{font-size:12.0pt;
	font-weight:bold;}
p.helpsubhead, li.helpsubhead, div.helpsubhead
	{font-size:10.0pt;}
p.helpcaption, li.helpcaption, div.helpcaption
	{font-size:10.0pt;}
p.helptab, li.helptab, div.helptab
	{font-size:10.0pt;}
p.sm, li.sm, div.sm
	{font-size:6.0pt;}
p.gowild, li.gowild, div.gowild
	{font-size:13.5pt;
	font-weight:bold;
	font-style:italic;}
p.getstarted, li.getstarted, div.getstarted
	{font-size:10.0pt;
	font-weight:bold;
	font-style:italic;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;}
div.Section1
	{page:Section1;}
-->
</style>

</head>

<body lang=EN-US link="#990000" vlink=purple>

<div class=Section1>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%;background:#ECECD9;border-collapse:collapse;border:none'>
 <tr>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="16.htm"><span style='text-decoration:none'><img
  border=0 width=37 height=34 src="leftarrw.gif"></span></a></p>
  </td>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><a href="0.htm"><span
  style='font-size:13.5pt'>Table of Contents</span></a></p>
  </td>
  <td width="34%" style='width:34.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=right style='text-align:right'><a href="18.htm"><span
  style='text-decoration:none'><img border=0 width=37 height=34
  src="rightarrw.gif"></span></a></p>
  </td>
 </tr>
</table>

</div>

<h2><a name="_Chapter_13._Databases"></a>Chapter 13. Databases</h2>

<p>Python can connect to a wide variety of databases using the various
integration technologies we’ve studied. Once you’ve made a connection, Python’s
lists and dictionaries make data manipulation simple and compact, and its
object model makes it easy to build object layers on top of databases.</p>

<p>We begin by surveying the various libraries available for connecting to a
relational database and executing queries. In the second half of the chapter,
we build some sample applications that demonstrate Python’s abilities to
manipulate data in sophisticated ways. We presume a knowledge of basic SQL and
familiarity with the concepts of relational databases.</p>

<h3><a name="_13.1_DAO,_ADO,_ODBC,_OLEDB,_and_Oth"></a>13.1 DAO, ADO, ODBC,
OLEDB, and Other GBFLAs</h3>

<p>Nowhere in the computing world do acronyms fly so thick and so fast as with
databases (GBFLAs stands for Great Big Five-Letter Acronyms). Microsoft has
produced a bewildering array of data-access APIs over the years. For most
applications, these will be the primary means of getting at your data. We’ll
run through the common ones and try to put them in context. If you are an
experienced Windows database developer, you may wish to skip ahead to the
section, <a href="17.htm#_13.3_Getting_at_Your_Data">Section 13.3</a>, later in
this chapter.</p>

<h4>13.1.1 Proprietary APIs</h4>

<p>Vendors of client/server systems such as Oracle and Sybase generally provide
a CD of client software to be installed on any PC that needs to connect to one
of their servers. This software often includes a tool to keep track of the
various database servers on the network, a custom network protocol on top of
TCP/IP, various administrative applications, command-line SQL clients, and
various programming interfaces to the database.</p>

<p>At the lowest level, C libraries and/or preprocessors are included to allow
C programs to execute queries against a database. Python modules have been
written around these libraries for (at least) Oracle, Sybase, Informix, Solid,
MySQL, and Interbase.</p>

<p>Proprietary APIs often give the fastest connections and allow access to
proprietary features of a particular database. However, SQL is supposed to be a
standard, and users want the freedom to switch databases without unreasonable
pain, so Microsoft has been working on standard interfaces to databases for
many years.</p>

<h4>13.1.2 Open Database Connectivity</h4>

<p>Open Database Connectivity (ODBC) is a standardized API that provides
universal database access and is available on all Windows systems.<a
name="_ftnref9"></a><a href="#_ftn9"><span class=atitlechar><sup><span
style='font-size:9.0pt'>[1]</span></sup></span></a> It consists of a DLL that
exposes standard functions to connect to and query databases, and a piece of
software to manage connections. Each database vendor still has to provide the
necessary software to connect to their own database, as well as an ODBC driver
that allows it to fit into the ODBC framework. Click Start <img border=0
width=20 height=16 src="images\image008.gif"
alt="figs/U2192.gif">Settings <img border=0 width=20 height=16
src="images\image008.gif" alt="figs/U2192.gif">Control
Panel <img border=0 width=20 height=16
src="images\image008.gif" alt="figs/U2192.gif">32-bit
ODBC to see the ODBC Data Source Administrator (see <a
href="#_Figure_13.1._ODBC_Data_Source_Admin">Figure 13.1</a>).</p>

<h5 align=center style='text-align:center'><a
name="_Figure_13.1._ODBC_Data_Source_Admin"></a>Figure 13.1. ODBC Data Source
Administrator</h5>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-family:Arial'><img border=0 width=502 height=324
src="images\image051.gif" alt="figs/ppw.1301.gif"></span></p>

<p>Each machine provides a list of named data sources; these can be configured
for a single user or available to the whole system. Clicking Add or Configure
leads to a set of dialogs specific to the database vendor; for example, for a
local Microsoft Access database you essentially just select the file to use.
Once a data source has been defined, any of your programs can connect to that
data source by name using ODBC.</p>

<p>This architecture has some enormous benefits. With care, it’s possible to
start prototyping with a data source named “Accounts” on a local Access
database, and then switch to using (for example) a remote Oracle server with
the same structure just by changing the configuration.</p>

<p>Because the capabilities of databases vary so widely, the ODBC API offers a
wide range of functions at three levels of compliance. Level 1 compliance is
the absolute minimum and is used for things like providing SQL access to text
files; Level 2 is generally regarded as the minimum feature set for anything
that is sold as a relational database.</p>

<p>ODBC will be our main tool for working with databases on Windows. We’ll go
through some examples later.</p>

<h4 style='page-break-after:avoid'>13.1.3 Data Access Objects, JET, and Access</h4>

<p>Microsoft Access is the world’s most popular desktop relational database,
used extensively for individual and small business systems. Although it can be
used on a network, it isn’t a proper client/server system. If five users share
a database across a network, there are five separate applications all opening
and closing the same data file. Access doesn’t scale up to high volumes of
users.</p>

<p>From the beginning, Access was split into a GUI (what you see when you start
Access) and an engine called Jet. The Data Access Object (DAO) hierarchy was an
object hierarchy for getting at the Jet engine; it contained objects to
represent databases, tables, relationships between tables, fields, and queries.
It was originally accessible only from Access and Visual Basic. The ability to
rapidly build database applications was one of the key factors in Visual Basic
3’s huge popularity. With the arrival of Office 95, the DAO hierarchy became a
full-fledged set of COM servers, allowing any COM-enabled language to open
databases.</p>

<p>The popularity of this development model rapidly led to a demand to connect
the same applications to client/server databases, and the DAO hierarchy was
extended allowing it to use ODBC connections under the hood as well as Access
databases. DAO now provides a comprehensive COM interface to a wide range of
databases. It is available on all Windows systems with Office 95 or 97.</p>

<h4>13.1.4 Remote Data Objects</h4>

<p>Remote Data Objects (RDO) is another COM object hierarchy, layered on top of
ODBC instead of the Jet engine. When you use DAO to get at an ODBC database,
you are actually using RDO objects. RDO is popular among corporate developers
because it offers support for features such as prepared statements and calling
stored procedures. The most visible manifestation of RDO is the Remote Data
Control in Visual Basic, which helped to remedy the truly appalling performance
of the Data Control when operating on remote databases.<a name="_ftnref10"></a><a
href="#_ftn10"><span class=atitlechar><sup><span style='font-size:9.0pt'>[2]</span></sup></span></a>
RDO is stable and works well, but is not as popular as DAO. It is unlikely to
be developed further.</p>

<h4>13.1.5 OLEDB</h4>

<p>OLEDB (which probably stands for Object Linking and Embedding Database, but
as far as we can tell has never been written out in full before now) is
intended as a successor to ODBC. ODBC allowed connection to relational
databases; OLEDB extends this to allow querying of arbitrary data providers
such as hierarchical filesystems, mailboxes in Microsoft Exchange, text files,
and nonrelational mainframes. It contains functionality to let you determine
the capabilities of a provider at runtime. Many database vendors have now
written OLEDB providers, and it can work through ODBC for those that have not.
OLEDB consists of a wide range of low-level COM interfaces, and OLEDB programming
is usually done by people writing database drivers; Microsoft provides an
easy-to-use layer above it, as we will see next.</p>

<h4>13.1.6 ActiveX Data Objects</h4>

<p>By now you should be sufficiently attuned to Microsoft terminology to
realize that terms using <i>Active </i>are (a) invented by their marketing
department and devoid of precise technical meanings and (b) probably something
to do with COM. ActiveX Data Objects (ADO) is not a new technology, but simply
an easy-to-use COM object hierarchy on top of OLEDB. It is bundled with Visual
Basic and Visual C++ 5.0 and higher; look in the MakePy window for Microsoft
ActiveX Data Objects Library 2.0. It looks superficially similar to DAO and RDO
but offers vastly greater capabilities under the hood and is thoroughly geared
to the needs of client/server systems. Microsoft has stated that they will put
no effort into further enhancements of RDO, DAO, and ODBC (although they are
committed to supporting ODBC for the long haul), so ADO sounds like the COM
interface of the future. Here are some of the enhancements offered:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>A programmer can trap events before or after commands are executed.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>A command object wraps stored procedures and simplifies setting
parameters.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>ADO exposes objects that wrap up the data definition language of a data
store, meaning you can write code to create and modify tables and indexes,
which works against a variety of underlying databases, even nonrelational ones.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>ADO supports hierarchical recordsets, which consist of prejoined master
and detail recordsets.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Disconnected recordsets and batch updates are perhaps the most exciting
features. An application for a salesman with a laptop could connect to a
database before going to fetch a recordset. The recordset can be kept open
after the connection to the database is closed and saved to and from files on
disk. On return, it can be resynchronized with the database. ADO takes care of
the persistence and of keeping track of what has changed.</p>

<p>The last three features will probably be exciting for Visual Basic
developers, since that language doesn’t let you get hold of data as directly as
Python; database data generally lives in a recordset throughout the life of a
program, and so, is less relevant to us. Experienced SQL developers prefer to
write their own <tt><span style='font-size:10.0pt'>CREATE TABLE</span></tt>
statements by hand and are quite happy without an object layer in the way.
Hierarchical data shaping and persistence are simple in Python, as you will see
shortly.</p>

<h4>13.1.7 So What's Worth Using?</h4>

<p>ODBC is our preferred interface technology. It is widely supported, here for
the long haul, and offers all the features serious database developers require.
There is an ODBC module included in the PythonWin distribution, and two
enhanced ones available for download, which we examine next. As you will see,
these provide the fastest and simplest ways of getting data out of a database
and into Python variables. DAO is of interest because it is a standard part of
Office and in such wide use; it may be relevant if you are dealing specifically
with Access databases. However, ADO seems set to take over and offers
significant benefits, as well as a fairly straightforward transition from DAO.
We show some examples of all three in the next section, but we’ll concentrate
mainly on ODBC for our more advanced examples.</p>

<h3 style='page-break-after:avoid'><a name="_13.2_Python's_Database_API"></a>13.2
Python's Database API</h3>

<p>Python has its own database API. This is intended so that people writing
wrappers around ODBC and vendor-specific database drivers should expose the
same database API to Python. The Database Special Interest Group (DB-SIG)
maintains the database API, and has a mailing list and archives relating to it
at <a href="http://www.python.org/sigs/db-sig/" target="_blank">http://www.python.org/sigs/db-sig/</a>.</p>

<p>Version 2.0 of this standard has just been released; we include a full copy
in <a href="30.htm#_Appendix_C._The_Python_Database_API">Appendix C</a>. The
various ODBC modules we demonstrate in this chapter conform closely to the
standard, so we will confine ourselves here to a brief discussion of what it
encompasses:</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Connection
objects</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Connection objects manage a connection to the
database. They can be opened and closed, and can commit and roll back
transactions. They may offer methods or properties to set global aspects of the
connection, such as transaction behavior. Everything else is done through
cursor objects.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Cursor
objects</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>These manage the context of a single statement.
Users ask the connection objects to create cursors, and assign an SQL statement
to the cursor. The cursor handles control of execution and of iteration through
the result set. It also defines a standard format for descriptive information
about the fields in the result set. Cursors provide support for parameterized
queries and prepared statements.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Standard
information provided</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>A database connection or module should be able to
return information about its capabilities. These include:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>The API level to which it conforms: level 2 offers many more features
than level 1. See <a href="30.htm#_Appendix_C._The_Python_Database_API">Appendix
C</a> for details.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>The parameter style to use for arguments to prepared statements; a
question mark is the most common.</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Information about how safe the module is to use with threads.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Standard
errors</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>A standard set of exceptions is defined for
database work, helping users to distinguish between SQL syntax errors,
integrity warnings in the database, invalid SQL, and so on.</p>

<p class=MsoNormal style='page-break-after:avoid'><i><span style='font-family:
Arial;color:#990000'>Standard data types</span></i><span style='font-family:
Arial'> </span></p>

<p style='margin-left:.5in'>Databases have special types to represent null,
dates and times, binary objects, and row IDs. Each DB-API-compliant module may
create its own objects to handle these, but the constructor for them is
defined. Thus, calling <tt><span style='font-size:10.0pt'>mymodule.Date(1999,12,31)</span></tt>
should return a valid <tt><span style='font-size:10.0pt'>Date</span></tt>
object suitable for insertion in the database, even if the implementation of
the <tt><span style='font-size:10.0pt'>Date</span></tt> object varies from one
database module to another.</p>

<p>The Python DB-API is simple and straightforward, yet offers the features
needed for high-performance database development.</p>

<p>Because it’s just been released, adherence to the new Version 2.0 database
API isn’t perfect, so we’ll briefly note the differences from the 1.0
specification. Version 1.0 offered the same connection and cursor objects, but
defined a shared helper module named DBI (presumably short for Database
Independence) that offered standard <tt><span style='font-size:10.0pt'>Date</span></tt>
and <tt><span style='font-size:10.0pt'>RAW</span></tt> types. It also did not
define the standard exceptions and driver information features.</p>

<p>As we noted earlier, there are many Python interface modules available;
generally, one for each database vendor. We will concentrate exclusively on the
ODBC modules, because ODBC drivers are available for virtually all database
servers.</p>

<h3><a name="_13.3_Getting_at_Your_Data"></a>13.3 Getting at Your Data</h3>

<p>In this section we show how to execute SQL queries and fetch data using
ODBC, DAO, and ADO. First, you need a database. The examples for this chapter
include an Access database called <i>pydbdemos.mdb</i> . You could as easily
use any database you can access, of course modifying the SQL statements as
needed. The sample database consists of a list of clients and invoices, with
the structure shown in <a href="17.htm#_Figure_13.2._Structure_of_PYDBDEMOS">Figure
13.2</a>.</p>

<h5 align=center style='text-align:center'><a
name="_Figure_13.2._Structure_of_PYDBDEMOS"></a>Figure 13.2. Structure of
PYDBDEMOS database</h5>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-family:Arial'><img border=0 width=502 height=191
src="images\image052.gif" alt="figs/ppw.1302.gif"></span></p>

<p>If you wish to use the sample database, you need to configure an ODBC data
source as follows:</p>

<p style='margin-left:.5in;text-indent:-.25in'>1.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Click on Start <img border=0 width=20 height=16
src="images\image008.gif" alt="figs/U2192.gif">Settings
<img border=0 width=20 height=16 src="images\image008.gif"
alt="figs/U2192.gif">Control Panel <img border=0 width=20 height=16
src="images\image008.gif" alt="figs/U2192.gif">32-bit
ODBC <img border=0 width=20 height=16 src="images\image008.gif"
alt="figs/U2192.gif">User (or system) DSN <img border=0 width=20 height=16
src="images\image008.gif" alt="figs/U2192.gif">Add.</p>

<p style='margin-left:.5in;text-indent:-.25in'>2.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Select Microsoft Access Driver from the list of drivers.</p>

<p style='margin-left:.5in;text-indent:-.25in'>3.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Enter the name <i>PYDBDEMOS</i> in the box for Data Source Name.</p>

<p style='margin-left:.5in;text-indent:-.25in'>4.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Click the Select button and locate the file <i>pydbdemos.mdb</i>.</p>

<p style='margin-left:.5in;text-indent:-.25in'>5.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Click OK. The new data source should now be visible in the list.</p>

<p style='margin-left:.5in;text-indent:-.25in'>6.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Click OK to close the ODBC Data Source Administrator. Some versions of
Windows contain a bug that causes an error message at this point. Ignore any
messages; your data source is registered correctly.</p>

<p>Since Access isn’t a server, we have worked with Sybase SQL Anywhere for
some of the advanced examples. This is an excellent commercial database engine
costing little more than Access and part of a range of products ranging from
embedded database engines to enterprise servers. We’ve kept the Sybase examples
to a minimum to illustrate the principles, and you certainly don’t need a
client/server system to follow this chapter. If you are working from home and
want to experiment with the techniques used in large-scale database
development, you’ll find that most commercial database vendors are generous
with extended evaluation copies and cut-down developer editions; their business
model is to charge for connections to servers, and it’s in their interest to
encourage developers to try them.</p>

<h4>13.3.1 Fetching Data with the PythonWin ODBC Module</h4>

<p>PythonWin includes an ODBC module that is mature and stable, but no longer
being developed and only Level 1.0-compliant. However, it has the advantage of
being small, light, and present in every PythonWin distribution. It depends on
the DBI module that defines certain data types (such as dates) and must be
imported first: more on this later. It consists of two extension files in the <i>win32</i>
subdirectory, <i>odbc.pyd</i> and <i>dbi.pyd</i> . Here’s how we fetch some
data:</p>

<pre>&gt;&gt;&gt; import dbi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #database independence utilities</pre><pre>&gt;&gt;&gt; import odbc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #the ODBC module itself</pre><pre>&gt;&gt;&gt; from pprint import pprint&nbsp;&nbsp;&nbsp; #pretty-print function</pre><pre>&gt;&gt;&gt; myconn = odbc.odbc('PYDBDEMOS')</pre><pre>&gt;&gt;&gt; mycursor = myconn.cursor()</pre><pre>&gt;&gt;&gt; mycursor.execute('SELECT ClientID, CompanyName, Address1 FROM Clients')</pre><pre>&gt;&gt;&gt; mydata = mycursor.fetchall()</pre><pre>&gt;&gt;&gt; mycursor.close()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #close cursor when done</pre><pre>&gt;&gt;&gt; myconn.close()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #close database when done</pre><pre>&gt;&gt;&gt; pprint(mydata)</pre><pre>[('MEGAWAD', 'MegaWad Investments', '1 St. Fredericks-Le-Grand'),</pre><pre> ('NOSHCO', 'NoshCo Supermarkets', '17 Merton Road'),</pre><pre> ('GRQ', 'GRQ Recruitment', None)]</pre><pre>&gt;&gt;&gt;</pre>

<p>The <tt><span style='font-size:10.0pt'>fetchall()</span></tt> method
converts the entire result set to a list of tuples of Python variables in one
call.</p>

<p>The <tt><span style='font-size:10.0pt'>connection</span></tt> object is constructed
with an ODBC connection string. It can be as simple as the data source name or
can include a username and password; a real-world connection string might looks
like this:</p>

<pre>DSN=MYDATABASE;UID=MYUSER;PWD=MYPASSWORD</pre>

<p>If you attempt to connect to a secure database without a password, the
database driver pops up a login dialog. Access has a default user ID, Admin,
and an empty password unless you enable security.</p>

<p>The <tt><span style='font-size:10.0pt'>cursor</span></tt> object manages a
query. Once the query has been executed, you can use it to get information
about the underlying fields. In the previous example you closed the cursor, but
if it was still open, you could do this:</p>

<pre>&gt;&gt;&gt; pprint(mycursor.description)</pre><pre>[('clientid', 'STRING', 10, 10, 0, 0, 1),</pre><pre> ('companyname', 'STRING', 50, 50, 0, 0, 1),</pre><pre> ('address1', 'STRING', 50, 50, 0, 0, 1)]</pre><pre>&gt;&gt;&gt;</pre>

<p>The seven elements are: <tt><span style='font-size:10.0pt'>name</span></tt>,
<tt><span style='font-size:10.0pt'>type_code</span></tt>, <tt><span
style='font-size:10.0pt'>display_size</span></tt>, <tt><span style='font-size:
10.0pt'>internal_size</span></tt>, <tt><span style='font-size:10.0pt'>precision</span></tt>,
<tt><span style='font-size:10.0pt'>scale</span></tt>, and <tt><span
style='font-size:10.0pt'>null_ok</span></tt>. Not all databases (or ODBC
drivers, or Python interfaces) provide this information, but all the ones we
have looked at manage the field name correctly.</p>

<p>Cursors also control how the information is retrieved. Some queries return
large sets of data, and it is inefficient to always send all of them across a
network to a client. We used the <tt><span style='font-size:10.0pt'>fetchall()</span></tt>
method to ask for every row of data. There are also <tt><span style='font-size:
10.0pt'>fetchone()</span></tt> and <tt><span style='font-size:10.0pt'>fetchmany()</span></tt>
methods, which retrieve either one row or a block of rows, moving forward
though the result set; they both return <tt><span style='font-size:10.0pt'>None</span></tt>
when they reach the end. Cursors have a property <tt><span style='font-size:
10.0pt'>arraysize</span></tt> you can set to determine the number of rows
retrieved by a call to <tt><span style='font-size:10.0pt'>fetchmany()</span></tt>.</p>

<h5>13.3.1.1 Update queries</h5>

<p>Cursors can also execute <tt><span style='font-size:10.0pt'>UPDATE</span></tt>
and <tt><span style='font-size:10.0pt'>INSERT</span></tt> statements or SQL
Data Definition Language statements, such as <tt><span style='font-size:10.0pt'>CREATE
TABLE</span></tt> . The call to <tt><span style='font-size:10.0pt'>execute()</span></tt>
returns the number of rows affected:</p>

<pre>&gt;&gt;&gt; mycursor = myconn.cursor()</pre><pre>&gt;&gt;&gt; mycursor.execute('UPDATE Invoices SET Hours=42 \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE InvoiceID=199904001')</pre><pre>1</pre><pre>&gt;&gt;&gt;</pre>

<p>However, at this point we reach a major limitation with the PythonWin ODBC
module: it doesn’t support prepared statements (at least not on any of the
database we tested against). If you don’t know what this means, rest assured,
all will be revealed at considerable length in the following sections.</p>

<h5>13.3.1.2 Working with dates</h5>

<p>For the most part, ordinary Python variables are exactly what one needs to
hold database values; they can hold integers, floating-point numbers, or
strings (including strings of large binary data). The previous console session
included the statement <tt><span style='font-size:10.0pt'>import</span></tt> <tt><span
style='font-size:10.0pt'>dbi</span></tt> at the beginning. This statement must
be executed prior to <tt><span style='font-size:10.0pt'>import</span></tt> <tt><span
style='font-size:10.0pt'>odbc</span></tt>. This module defines a date type to
use when working with databases, as well as the standard data types used by the
ODBC API. Let’s try a query that returns some dates and play with them. Assume
the connection is still open:</p>

<pre>&gt;&gt;&gt; mycursor = myconn.cursor()</pre><pre>&gt;&gt;&gt; mycursor.execute('SELECT ClientID, InvoiceDate, Consultant, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hours FROM Invoices')</pre><pre>&gt;&gt;&gt; mydata = mycursor.fetchall()</pre><pre>&gt;&gt;&gt; pprint(mydata)</pre><pre>[('MEGAWAD', &lt;DbiDate object at 10f0dc0&gt;, 'Joe Hacker', 40L),</pre><pre> ('MEGAWAD', &lt;DbiDate object at 10f0c40&gt;, 'Arthur Suit', 24L),</pre><pre> ('MEGAWAD', &lt;DbiDate object at 10f1ed0&gt;, 'Joe Hacker', 57L),</pre><pre> ('NOSHCO', &lt;DbiDate object at 10f1e00&gt;, 'Tim Trainee', 18L)]</pre><pre>&gt;&gt;&gt; dateobj = mydata[0][1]&nbsp;&nbsp; # grab the date from the first row</pre><pre>&gt;&gt;&gt; dateobj</pre><pre>&lt;DbiDate object at 10f0dc0&gt;</pre><pre><span
lang=DE>&gt;&gt;&gt; int(dateobj)</span></pre><pre><span lang=DE>924044400</span></pre><pre><span
lang=DE>&gt;&gt;&gt; str(dateobj)</span></pre><pre><span lang=DE>'Wed Apr 14 00:00:00 1999'</span></pre><pre><span
lang=DE>&gt;&gt;&gt; print dateobj</span></pre><pre>Wed Apr 14 00:00:00 1999</pre><pre>&gt;&gt;&gt;</pre>

<p>Dates are returned as <tt><span style='font-size:10.0pt'>DbiDate</span></tt>
objects. These can be treated as integers or floating point numbers, in which
case you get the number of seconds since January 1, 1970 (the Python and Unix
time system), or as strings, in which case you get a printable representation.</p>

<p>When modifying or inserting rows in a database, the syntax and format
options may vary from vendor to vendor. However, there is also a standard ODBC
syntax for embedding dates in SQL strings that should always work. That syntax
uses the format <tt><span style='font-size:10.0pt'>{d</span></tt> <tt><span
style='font-size:10.0pt'>'yyyy-mm-dd'}</span></tt>. With Microsoft databases
you can also use either a string enclosed with hashes, or a Microsoft date
serial number,<a name="_ftnref11"></a><a href="#_ftn11"><span class=atitlechar><sup><span
style='font-size:9.0pt'>[3]</span></sup></span></a> which is based on the
number of days since 1900:</p>

<pre>&gt;&gt;&gt; mycursor.execute('UPDATE Invoices SET InvoiceDate={d '1999-04-15' }</pre><pre> WHERE InvoiceID=199904001')&nbsp;&nbsp;&nbsp; # preferred</pre><pre>1</pre><pre>&gt;&gt;&gt; mycursor.execute('UPDATE Invoices SET InvoiceDate=36265 WHERE InvoiceID=199904001')</pre><pre>1</pre><pre>&gt;&gt;&gt; mycursor.execute('UPDATE Invoices SET InvoiceDate=#15-Apr-99# WHERE InvoiceID=199904001')</pre><pre>1</pre><pre>&gt;&gt;&gt; </pre>

<h4>13.3.2 The mxODBC and mxDateTime Extensions</h4>

<p>The ODBC module distributed with PythonWin is a minimal implementation, and
conforms to Version 1.0 of the Python Database API. It’s stable and works well,
but is unlikely to be developed further. Then again, neither is ODBC!<a
name="_ftnref12"></a><a href="#_ftn12" title=""><span class=atitlechar><sup><span
style='font-size:9.0pt'>[4]</span></sup></span></a></p>

<p class=footnote style='margin-right:.5in'>If you work extensively with
databases, check out Marc-André Lemburg’s <tt><span style='font-size:10.0pt'>mxODBC</span></tt>
extension package, available from <a
href="http://starship.python.net/crew/lemburg/" target="_blank">http://starship.python.net/crew/lemburg/</a>.
One of its many features is an enhanced set of date and time types to save you
from worrying about Microsoft and Unix date systems. These are available as a
separate package, <tt><span style='font-size:10.0pt'>mxDateTime</span></tt>,
which can be used in nondatabase applications. <tt><span style='font-size:10.0pt'>mxODBC</span></tt>
also runs on Unix. <tt><span style='font-size:10.0pt'>mxODBC</span></tt><i> </i>has
some licensing restrictions; check the web site for the latest details.</p>

<p><tt><span style='font-size:10.0pt'>mxDateTime</span></tt><i> </i>and <tt><span
style='font-size:10.0pt'>mxODBC</span></tt><i> </i>are both shipped as packages
that should be unzipped somewhere on the Python path.<a name="_ftnref13"></a><a
href="#_ftn13"><span class=atitlechar><sup><span style='font-size:9.0pt'>[5]</span></sup></span></a>
The latter creates a directory and package named—you guessed it—ODBC. There is
a naming collision with the old ODBC module, which lives in <i>...Python\win32\odbc.pyd</i>
; we suggest renaming this to something else, such as <i>win32odbc.pyd,</i> so
that you can still access the old module if you want to (note, however, that
you need to rename the module back to the original <i>odbc.pyd</i> before it
can be used again). It contains a number of subpackages aimed at other
platforms; the functionality we want is in the module <tt><span
style='font-size:10.0pt'>ODBC.Windows</span></tt> . Let’s give it a try:</p>

<pre>&gt;&gt;&gt; import ODBC.Windows</pre><pre>&gt;&gt;&gt; conn = ODBC.Windows.Connect('PYDBDEMOS')</pre><pre>&gt;&gt;&gt; cursor = conn.cursor()</pre><pre>&gt;&gt;&gt; cursor.execute('SELECT InvoiceID, ClientID, InvoiceDate FROM Invoices') </pre><pre>&gt;&gt;&gt; from pprint import pprint</pre><pre>&gt;&gt;&gt; pprint(cursor.description)</pre><pre>(('InvoiceID', 4, None, None, 10, 0, 1),</pre><pre> ('ClientID', 12, None, None, 10, 0, 1),</pre><pre> ('InvoiceDate', 11, None, None, 19, 0, 1))</pre><pre>&gt;&gt;&gt; data = cursor.fetchall()</pre><pre>&gt;&gt;&gt; pprint(data)</pre><pre>[(199904001, 'MEGAWAD', 1999-04-15 00:00:00.00),</pre><pre> (199904002, 'MEGAWAD', 1999-04-14 00:00:00.00),</pre><pre> (199904003, 'MEGAWAD', 1999-04-21 00:00:00.00),</pre><pre> (199904004, 'NOSHCO', 1999-04-22 00:00:00.00)]</pre>

<p>As can be seen, the interface is almost identical. A recent change in the
Python Database API has been to use <tt><span style='font-size:10.0pt'>Connect()</span></tt>
as the constructor for connection objects rather than <tt><span
style='font-size:10.0pt'>ODBC()</span></tt>, but <tt><span style='font-size:
10.0pt'>mxODBC</span></tt><i> </i>supports both forms, as well as the lower
case <tt><span style='font-size:10.0pt'>connect()</span></tt>.</p>

<h5>13.3.2.1 Enhanced connection control</h5>

<p><tt><span style='font-size:10.0pt'>mxODBC</span></tt> offers access to a
wide range of options and SQL constants that can control the behavior of a
connection. The most important of these determines whether the connection
commits every statement as it’s executed or accumulates them in a transaction.
The default behavior is to begin a transaction, so that changes to the database
are permanent only when a user calls <tt><span style='font-size:10.0pt'>cursor.commit()</span></tt>.
This can be modified two ways. First of all, when connecting, one can supply an
argument as follows:</p>

<pre>&gt;&gt;&gt; myconn = ODBC.Windows.Connect('PYDBDEMOS',clear_auto_commit=1)</pre><pre>&gt;&gt;&gt;</pre>

<p>Second, one can set this and a wide range of other options through the <tt><span
style='font-size:10.0pt'>setconnectoption(option,</span></tt> <tt><span
style='font-size:10.0pt'>value)</span></tt> and <tt><span style='font-size:
10.0pt'>getconnectoption(option)</span></tt> methods. The <tt><span
style='font-size:10.0pt'>SQL</span></tt> object provides access to the full set
of 636 ODBC constants that (among other things) define the options and possible
values. Thus, you can achieve the same with:</p>

<pre>&gt;&gt;&gt; myconn.setconnectoption(SQL.AUTOCOMMIT, SQL.AUTOCOMMIT_ON)</pre><pre>&gt;&gt;&gt; myconn.getconnectoption(SQL.AUTOCOMMIT)</pre><pre>1</pre><pre>&gt;&gt;&gt;</pre>

<p>This feature allows access to most of the key capabilities of ODBC drivers.</p>

<h5>13.3.2.2 The mxDateTime package</h5>

<p>Now we’ll take a quick look at the date and time functionality. The <tt><span
style='font-size:10.0pt'>mxDateTime</span></tt> package was developed after
much discussion on the Python DB-SIG to provide a platform-independent way to
move date and time data between databases and applications. Its internal epoch
is the year dot, giving it a far greater range than COM dates. The first thing
to note is that the date objects in the previous session were smart enough to
represent themselves in a readable manner! We’ll grab a date out of the row
above and play with it:</p>

<pre>&gt;&gt;&gt; aDateTime = data[0][2]</pre><pre>&gt;&gt;&gt; type(aDateTime)</pre><pre>&lt;type 'DateTime'&gt;</pre><pre>&gt;&gt;&gt; int(aDateTime)</pre><pre>924130800</pre><pre>&gt;&gt;&gt; str(aDateTime)</pre><pre>'1999-04-15 00:00:00.00'</pre><pre>&gt;&gt;&gt;</pre>

<p><tt><span style='font-size:10.0pt'>mxDateTime</span></tt><i> </i>also
provides a large array of constants, methods, and submodules to perform date and
calendar calculations, parse dates, and even work out holidays. The following
snippet should give you a feel:</p>

<pre>&gt;&gt;&gt; import DateTime</pre><pre>&gt;&gt;&gt; DateTime.DateTimeFromCOMDate(0) # the Microsoft system</pre><pre>1899-12-30 00:00:00.00</pre><pre>&gt;&gt;&gt; aDateTime.COMDate()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # convert to Microsoft COM/Excel dates</pre><pre>36265.0</pre><pre>&gt;&gt;&gt; </pre><pre>&gt;&gt;&gt; DateTime.now() - aDateTime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # RelativeDateTime object</pre><pre>&lt;DateTimeDelta object for '16:23:40:16.18' at 1106530&gt;</pre><pre>&gt;&gt;&gt; aDateTime + DateTime.RelativeDateTime(months=+3)</pre><pre>1999-07-15 00:00:00.00</pre><pre>&gt;&gt;&gt; # first of next month... </pre><pre>&gt;&gt;&gt; aDateTime + DateTime.RelativeDateTime(months=+1,day=1)</pre><pre>1999-05-01 00:00:00.00</pre><pre>&gt;&gt;&gt; DateTime.now()</pre><pre>1999-05-01 23:42:20.15</pre><pre>&gt;&gt;&gt; DateTime.Feasts.EasterSunday(2001)</pre><pre>2001-04-15 00:00:00.00</pre><pre>&gt;&gt;&gt; DateTime.Parser.DateFromString('Friday 19th October 1987')</pre><pre>1987-10-19 00:00:00.00</pre><pre>&gt;&gt;&gt;</pre>

<p>A <tt><span style='font-size:10.0pt'>DateTimeDelta</span></tt> is defined
for the difference between two points in time, and there are a full set of
mathematical operations defined. Submodules include date parsers, holidays, and
routines for ARPA and ISO dates. A large number of business applications need
to handle dates and times intelligently, and these functions make it extremely
easy and quick.</p>

<h5>13.3.2.3 Support for prepared statements</h5>

<p>One of the key advantages of <tt><span style='font-size:10.0pt'>mxODBC</span></tt>
is that it properly supports prepared statements. While these will be familiar
to database programmers who work in C, they may not be to people used to
standard Visual Basic or Delphi database development tools, so we’ll explain
the background.</p>

<p>There are two stages to the execution of an SQL statement. First, the
database parses the SQL, works out a plan for executing the query, and compiles
it into an executable routine. Second, the database executes the statement and
returns the result set. For complex queries joining several tables, the parsing
is not a trivial step, and may involve some analysis of the size of tables and
the best order in which to filter records. It also consumes a large amount of
memory compared to the subsequent execution.</p>

<p>If you wish to perform the same kind of query repeatedly (for example,
inserting 1,000 rows in a table), the statement could, in theory, be parsed
only once, leading to substantial performance gains. To support this, it’s
necessary to separate the SQL statement structure from the actual parameters to
go into the database.</p>

<p>If you are working with ODBC in C, you execute one call to get a handle to
the SQL statement, then others to actually call it repeatedly with differing
data. In Python it is much simpler: just parameterize the statement, using a
question mark as a placeholder:</p>

<pre>&gt;&gt;&gt; stmt = &quot;UPDATE Invoices SET Hours = ? WHERE InvoiceID = ?&quot;</pre><pre>&gt;&gt;&gt; mycursor.execute(stmt, (45, 199904001))</pre><pre>1</pre><pre>&gt;&gt;&gt;</pre>

<p><tt><span style='font-size:10.0pt'>mxODBC</span></tt> and any other
DBAPI-compliant interface do the right thing to pass the arguments to the
database, whatever their type. Don’t confuse this with Python’s modulo operator
for substituting into strings.</p>

<p>At this point you’ve executed only a single statement. However, the cursor
object is now caching a handle to the prepared statement; so a subsequent call
of the form <tt><span style='font-size:10.0pt'>cursor.execute(stmt,</span></tt>
<tt><span style='font-size:10.0pt'>newdata)</span></tt> will be much faster on
any client/server database. Later in the chapter, you’ll discover how much
faster, when we benchmark a range of data access methods.</p>

<p>If you have a large block of data to insert or update, there’s a method
named <tt><span style='font-size:10.0pt'>executemany()</span></tt>,<a
name="_ftnref14"></a><a href="#_ftn14" title=""><span class=atitlechar><sup><span
style='font-size:9.0pt'>[6]</span></sup></span></a> which takes a block or rows
and saves the need to write a Python loop to insert each one. The following
snippet shows the most efficient way to do a bulk insertion or update. The SQL
statement is parsed only once:</p>

<pre>&gt;&gt;&gt; mycursor.executemany(stmt, </pre><pre>...&nbsp;&nbsp;&nbsp; [ #begin a list of values</pre><pre>...&nbsp;&nbsp;&nbsp;&nbsp; (45, 199904001),</pre><pre>...&nbsp;&nbsp;&nbsp;&nbsp; (53, 199904002),</pre><pre>...&nbsp;&nbsp;&nbsp;&nbsp; (52, 199904003)</pre><pre>...&nbsp;&nbsp;&nbsp; ] )</pre><pre>1</pre><pre>&gt;&gt;&gt;</pre>

<p>Note that the block of data supplied is a list of tuples, the same format
returned from <tt><span style='font-size:10.0pt'>fetchall()</span></tt> or from
2D COM arrays. Other languages let you work with one field at a time; Python
lets you manipulate whole blocks of data in a single line!</p>

<p>The importance of prepared statements is hard to overstate. First of all, on
single queries on a database that is being used lightly, there can be an
increase of up to 50% in query execution. Second, if a system is designed to
use only prepared statements, it consumes far less server memory, enabling it
to support many more users and perform better under heavy loads. Third, it
saves you a lot of work; there’s no need to build the full SQL string yourself,
leaving you free to concentrate purely on manipulating blocks of Python
variables.</p>

<h5>13.3.2.4 Calling stored procedures</h5>

<p>One key feature offered by client/server databases (but not Microsoft
Access) is the <i>stored procedure</i> . This is a named, precompiled procedure
in the database that may be called from outside: conceptually, a function you
can call, complete with arguments. As well as offering the same performance
benefits as prepared statements, these allow the database to encapsulate
business logic. For example, rather than letting developers directly execute
SQL on a group of tables relating to invoices, database administrators can
provide an interface allowing the users to add, edit (only where appropriate),
and query interfaces. This is standard practice in many companies, and ad hoc
queries by users are sometimes banned because of concerns over database
integrity or performance.</p>

<p>Access doesn’t offer this feature, so we’ll switch to a demonstration
version of Sybase Adaptive Server Anywhere. The example database provided
includes tables of customers and products, and a stored procedure interface to
them. The procedure <tt><span style='font-size:10.0pt'>sp_product_info</span></tt>
accepts a product ID as argument and returns information on that product
gathered from several tables.</p>

<p>The DBAPI recommends that cursors can optionally offer a method named <tt><span
style='font-size:10.0pt'>callproc(</span></tt> <tt><i><span style='font-size:
10.0pt'>procname,</span></i></tt> <tt><i><span style='font-size:10.0pt'>[parameters]</span></i></tt><tt><span
style='font-size:10.0pt'>)</span></tt>. It’s optional because many databases,
such as mySQL and Access, don’t offer stored procedures. At the time of writing
this was not yet implemented in <tt><span style='font-size:10.0pt'>mxODBC</span></tt>.
Nevertheless, they can be called using standard SQL without trouble, as
follows: </p>

<pre>&gt;&gt;&gt; mycursor.execute('sp_product_info(500)')</pre><pre>&gt;&gt;&gt; mycursor.fetchall()</pre><pre>[(500, 'Visor', 'Cloth Visor', 'One size fits all', 'White', 36, 7.0)]</pre><pre>&gt;&gt;&gt; mycursor.execute('CALL sp_product_info(500)')</pre><pre>&gt;&gt;&gt; mycursor.fetchall()</pre><pre>[(500, 'Visor', 'Cloth Visor', 'One size fits all', 'White', 36, 7.0)]</pre><pre>&gt;&gt;&gt; mycursor.execute('EXEC sp_product_info(500)')</pre><pre>&gt;&gt;&gt; mycursor.fetchall()</pre><pre>[(500, 'Visor', 'Cloth Visor', 'One size fits all', 'White', 36, 7.0)]</pre>

<h4>13.3.3 Sam Rushing's ODBC Module</h4>

<p>There is a third Python module for working with ODBC that operates on
different lines. Sam Rushing (<a href="http://www.nightmare.com" target="_blank">http://www.nightmare.com</a>)
specializes in low-level work with Python and Windows and has produced a package
named <tt><span style='font-size:10.0pt'>calldll</span></tt> that allows Python
programs to dynamically load and call any function in a DLL. We discuss how
this works in <a href="26.htm#_Chapter_22._Extending_and_Embedding">Chapter 22</a>.
It has allowed Sam to produce an ODBC module that wraps and exposes almost
every function in Microsoft’s ODBC.DLL. To install this, you need to download
the two files <i>calldll.zip</i> and <i>dynwin.zip</i> from his site. The
latter contains a number of modules relating to ODBC. Naturally, one of these
is called <i>odbc.py</i>, so you need to watch for name collisions. If you’ve
been using the previous two modules, rename them out of the way before
starting.</p>

<p>As with the other modules, <tt><span style='font-size:10.0pt'>calldll</span></tt>
provides a safe, easy-to-use high-level interface for querying databases, but
it bears no resemblance to the DBAPI. Here’s the high-level usage:</p>

<pre>&gt;&gt;&gt; import odbc</pre><pre>&gt;&gt;&gt; env = odbc.environment()</pre><pre>&gt;&gt;&gt; conn = env.connection()</pre><pre>&gt;&gt;&gt; conn.connect('accessdemo')</pre><pre>&gt;&gt;&gt; import pprint</pre><pre>&gt;&gt;&gt; pp = pprint.pprint</pre><pre>&gt;&gt;&gt; results = conn.query('SELECT * FROM Invoices')</pre><pre>&gt;&gt;&gt; pp(results[0])&nbsp; #field information</pre><pre>[('InvoiceID', 4, 10, 0, 1),</pre><pre> ('ClientID', 12, 10, 0, 1),</pre><pre> ('InvoiceDate', 11, 19, 0, 1),</pre><pre> ('Consultant', 12, 50, 0, 1),</pre><pre> ('PeriodEnding', 11, 19, 0, 1),</pre><pre> ('Hours', 8, 15, 0, 1),</pre><pre> ('HourlyRate', 2, 19, 4, 1),</pre><pre> ('Expenses', 2, 19, 4, 1),</pre><pre> ('ExpenseDetails', 12, 50, 0, 1),</pre><pre> ('TaxRate', 8, 15, 0, 1),</pre><pre> ('Comments', 12, 50, 0, 1),</pre><pre> ('DatePaid', 11, 19, 0, 1)]</pre><pre>&gt;&gt;&gt; pp(results[1])&nbsp; #first data row</pre><pre>['199904001',</pre><pre> 'MEGAWAD',</pre><pre> '1999-12-31 00:00:00',</pre><pre> 'Joe Hacker',</pre><pre> '1999-04-18 00:00:00',</pre><pre> '43.0',</pre><pre> '50.0000',</pre><pre> '0.0000',</pre><pre> None,</pre><pre> '0.175',</pre><pre> None,</pre><pre> None]</pre><pre>&gt;&gt;&gt;</pre>

<p>The high-level interface includes classes to represent the environment,
connections, and statements. Perhaps of more interest is what happens when you
drop down a level. Sam has encapsulated the idea of an ODBC function call in a
general way. Let’s take a look at his own source code for the <tt><span
style='font-size:10.0pt'>connect()</span></tt> method:</p>

<pre>def connect (self, dsn, uid='', auth=''):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dsn&nbsp;&nbsp;&nbsp; = cstring (dsn)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.uid&nbsp;&nbsp;&nbsp; = cstring (uid)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.auth&nbsp;&nbsp;&nbsp; = cstring (auth)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = odbc.SQLConnect (</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # connection handle</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dsn, self.dsn.strlen(),&nbsp;&nbsp;&nbsp;&nbsp; # data source name</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.uid, self.uid.strlen(),&nbsp;&nbsp;&nbsp;&nbsp; # user identifier</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.auth, self.auth.strlen(),&nbsp;&nbsp; # authentication (password)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if retval in (SQL_SUCCESS, SQL_SUCCESS_WITH_INFO):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.connected = 1</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise error, 'SQLConnect failed: %d' % retval</pre>

<p>If you’re an experienced ODBC programmer working from C or C++, you’ll
recognize the call to <tt><span style='font-size:10.0pt'>SQLConnect</span></tt>
and the constant values such as <tt><span style='font-size:10.0pt'>SQL_SUCCESS</span></tt>.
The ODBC module in <tt><span style='font-size:10.0pt'>DynWin</span></tt>
exposes the entire ODBC API to the programmer, offering the same possibilities
as with programming in C.</p>

<p>One word of warning: while the high-level interface is reliable and quite
friendly, the technologies underneath <tt><span style='font-size:10.0pt'>DynWin</span></tt>
and <tt><span style='font-size:10.0pt'>calldll</span></tt> are less forgiving
than most Python extensions. If you drop down to the lowest levels and call ODBC
functions with the wrong arguments, it’s possible to corrupt the stack and
crash your program, the same as in C.</p>

<p>We expect this module to be of interest to experienced C and C++ programmers
who know the ODBC API and wish to work with it at a low level. If this doesn’t
describe you, stick with the other ODBC modules; the performance is the same,
but the interface operates at a much higher level of convenience.</p>

<h4 style='page-break-after:avoid'>13.3.4 Connecting with Data Access Objects</h4>

<p>The Data Access Object hierarchy is installed on your system if you have
Microsoft Office, Access, or Visual Basic, or if you have ever installed a VB
application that works with MDB files. It doesn’t need an ODBC data source
configured. We recommend running MakePy<i> </i>over the latest version of the
Microsoft DAO Library on your system, as seen in <a
href="#_Figure_13.3._MakePy_showing_the_DAO">Figure 13.3</a>.</p>

<h5 align=center style='text-align:center'><a
name="_Figure_13.3._MakePy_showing_the_DAO"></a>Figure 13.3. MakePy showing the
DAO and ADO libraries</h5>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-family:Arial'><img border=0 width=502 height=286
src="images\image053.gif" alt="figs/ppw.1303.gif"></span></p>

<p>The hierarchy starts with a database engine (class <tt><span
style='font-size:10.0pt'>DBEngine</span></tt>) and allows you to open multiple <tt><span
style='font-size:10.0pt'>Database</span></tt> objects. Once a database is open
you can create <tt><span style='font-size:10.0pt'>Recordset</span></tt> objects
that are the broad equivalent of a cursor in the Python Database API. You can
navigate through a <tt><span style='font-size:10.0pt'>Recordset</span></tt> and
edit its fields. A <tt><span style='font-size:10.0pt'>Field</span></tt> is an
object too, with a <tt><span style='font-size:10.0pt'>Name</span></tt>, a <tt><span
style='font-size:10.0pt'>Value</span></tt>, and many more properties.</p>

<p>Let’s start by connecting to the same database as before. This time you
don’t need the ODBC data source, but can go straight for the file:</p>

<pre>&gt;&gt;&gt; import win32com.client</pre><pre>&gt;&gt;&gt; daoEngine = win32com.client.Dispatch('DAO.DBEngine')</pre><pre>&gt;&gt;&gt; daoDB = daoEngine.OpenDatabase('C:\\MYDIR\\pydbdemos.mdb')</pre><pre>&gt;&gt;&gt; daoRS = daoDB.OpenRecordset('SELECT ClientID, InvoiceDate, \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Consultant, Hours FROM Invoices')</pre><pre>&gt;&gt;&gt; daoRS.MoveLast()&nbsp;&nbsp;&nbsp;&nbsp; # need to do this to get an accurate size</pre><pre>&gt;&gt;&gt; daoRS.RecordCount</pre><pre>4</pre><pre>&gt;&gt;&gt;</pre>

<p>Opening the database and getting the result set is no harder than with the
Python API and ODBC. However, instead of calling <tt><span style='font-size:
10.0pt'>fetchall()</span></tt> to create a Python list of tuples, you have a <tt><span
style='font-size:10.0pt'>Recordset</span></tt> object through which you must
iterate. Before, you stepped to the end and got a record count. Now let’s look
at some data:</p>

<pre>&gt;&gt;&gt; daoRS.MoveLast()</pre><pre>&gt;&gt;&gt; daoRS.Fields('ClientID').Value&nbsp;&nbsp; # reference fields by name</pre><pre>'NOSHCO'</pre><pre>&gt;&gt;&gt; daoRS.Fields(3).Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # or by position</pre><pre>18.0</pre><pre>&gt;&gt;&gt; for i in range(daoRS.Fields.Count):</pre><pre>...&nbsp;&nbsp;&nbsp;&nbsp; daoField = daoRS.Fields[i]</pre><pre>...&nbsp;&nbsp;&nbsp;&nbsp; print '%s = %s' % (daoField.Name, daoField.Value)</pre><pre>... </pre><pre>ClientID = NOSHCO</pre><pre>InvoiceDate = &lt;time object at 1191860&gt;</pre><pre>Consultant = Tim Trainee</pre><pre>Hours = 18.0</pre><pre>&gt;&gt;&gt;</pre>

<p>The normal mode of operations is to work a field at a time, asking for the
exact values you want. However, there’s a method called <tt><span
style='font-size:10.0pt'>Recordset.GetRows(</span></tt> <tt><i><span
style='font-size:10.0pt'>[rows_to_fetch]</span></i></tt>) that can grab data in
bulk. It returns the next few rows from the current position:</p>

<pre>&gt;&gt;&gt; daoRS.MoveFirst()</pre><pre>&gt;&gt;&gt; data = daoRS.GetRows(4)</pre><pre>&gt;&gt;&gt; pprint(data)</pre><pre>((L'MEGAWAD', L'MEGAWAD', L'MEGAWAD', L'NOSHCO'),</pre><pre> (&lt;time object at 11921f0&gt;,</pre><pre>&nbsp; &lt;time object at 11921d0&gt;,</pre><pre>&nbsp; &lt;time object at 11921b0&gt;,</pre><pre>&nbsp; &lt;time object at 1192190&gt;),</pre><pre> (L'Joe Hacker', L'Arthur Suit', L'Joe Hacker', L'Tim Trainee'),</pre><pre> (42.0, 24.0, 57.0, 18.0))</pre>

<p>There are two things to notice. First, <tt><span style='font-size:10.0pt'>GetRows()</span></tt>
returns columns, not rows. The matrix is transposed compared to the Python
representation. Second, this is a COM server, so you get back Unicode strings
and the date objects defined by the Python COM framework. As a reminder, let’s
take another look at the third date type:</p>

<pre>&gt;&gt;&gt; aDate = data[1][0]&nbsp;&nbsp; # remember how these dates work?</pre><pre>&gt;&gt;&gt; type(aDate)</pre><pre>&lt;type 'time'&gt;</pre><pre>&gt;&gt;&gt; int(aDate)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # can coerce to a Python date...</pre><pre>924130800</pre><pre>&gt;&gt;&gt; aDate.Format()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ...and knows how to display itself</pre><pre>'04/15/99 00:00:00'</pre><pre>&gt;&gt;&gt;</pre>

<p>It’s possible to update and insert records using DAO, but the normal
technique is to use the <tt><span style='font-size:10.0pt'>Edit()</span></tt>
and <tt><span style='font-size:10.0pt'>AddNew()</span></tt> methods of a <tt><span
style='font-size:10.0pt'>RecordSet</span></tt> as follows:</p>

<pre>&gt;&gt;&gt; daoRS2 = daoDB.OpenRecordset('SELECT * FROM Clients')</pre><pre>&gt;&gt;&gt; daoRS2.AddNew()</pre><pre>&gt;&gt;&gt; daoRS2.Fields('ClientID').Value = 'WOMBLES'</pre><pre>&gt;&gt;&gt; daoRS2.Fields('CompanyName').Value = 'Wimbledon Garbage Disposal Ltd.'</pre><pre>&gt;&gt;&gt; daoRS2.Fields('ContactName').Value = 'Uncle Bulgaria'</pre><pre>&gt;&gt;&gt; daoRS2.Update()&nbsp;&nbsp;&nbsp;&nbsp; # save the record</pre><pre>&gt;&gt;&gt; daoRS2.Close()</pre>

<p>To modify an existing record, use <tt><span style='font-size:10.0pt'>Edit()</span></tt>
rather than <tt><span style='font-size:10.0pt'>AddNew()</span></tt> at the
beginning.</p>

<p>This highlights what is arguably a benefit of the DAO model: the database
does type checking on individual fields as you assign them. If you try to put a
string in a date field, you get an error on the relevant line of code, whereas
debugging long <tt><span style='font-size:10.0pt'>UPDATE</span></tt> or <tt><span
style='font-size:10.0pt'>INSERT</span></tt> statements can take a little
longer. However, for large volumes of insertions, working with an ODBC module’s
<tt><span style='font-size:10.0pt'>executemany()</span></tt> method is simpler
since there is no need to loop over the fields in Python and DAO. </p>

<h4>13.3.5 Connecting with ADO</h4>

<p>ADO looks almost identical to DAO at this level of detail; Microsoft
simplified the object model considerably but kept the essentials the same. The
big differences are that (a) data providers other than ODBC are permitted, and
(b) all the Access specifics, including direct access to tables and
relationships, have been dropped. The data provider can be specified either in
a connection string or in a <tt><span style='font-size:10.0pt'>Provider</span></tt>
property of the <tt><span style='font-size:10.0pt'>Connection</span></tt>
object, before the connection is opened. Microsoft has data providers for the following
applications at present:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>ODBC</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Microsoft Index Server</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Active Directory Services</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Jet engine (via DAO)</p>

<p>So, despite all the hype, you’re still going to use either ODBC or DAO under
the hood somewhere. We’ll use our ODBC alias again:</p>

<pre>&gt;&gt;&gt; import win32com.client</pre><pre>&gt;&gt;&gt; adoConn = win32com.client.Dispatch('ADODB.Connection')</pre><pre>&gt;&gt;&gt; adoConn.Open('PYDBDEMOS')&nbsp; # use our ODBC alias again</pre><pre>&gt;&gt;&gt; (adoRS, success) = adoConn.Execute('SELECT * FROM Clients')</pre><pre>&gt;&gt;&gt; adoRS.MoveFirst()</pre><pre>&gt;&gt;&gt; adoRS.Fields(&quot;CompanyName&quot;).Value</pre><pre>'MegaWad Investments'</pre><pre>&gt;&gt;&gt;</pre>

<p>Adding, editing, and using <tt><span style='font-size:10.0pt'>GetRows()</span></tt>
is identical to DAO. We won’t go into the advanced capabilities of ADO here;
numerous references are available.</p>

<p>You should use ADO if you know it’s installed on client machines, because
it’s the COM API of the future. However, at the time of writing, you can count
on DAO being present on all machines with a copy of Office, and ADO is not yet
so widespread. If you stick to basic SQL statements, porting code between the
two should be easy.</p>

<h3 style='page-break-after:avoid'><a name="_13.4_A_Note_on_Speed"></a>13.4 A
Note on Speed</h3>

<p>With database systems, performance is always important. A badly designed
client/server system can cost a great deal of money and have a shorter life
than planned if attention is not paid to the way client applications interact
with the server. Even with PC-based systems such as Access, database
applications can often become slow, especially when multiple dynamic views of
the data are used. Having discussed a wide range of data-access techniques, we
now include some rough performance benchmarks. These are intended to show only
the rough characteristics of different data-access APIs.</p>

<p>The standard task covered is to insert 1,000 rows into a simple table. The
sample table, named <i>analysis</i>, can be thought of as a crude repository
for financial data; it has four fields, <tt><span style='font-size:10.0pt'>tranid</span></tt><i>
</i>(integer), <tt><span style='font-size:10.0pt'>trandate</span></tt><i> </i>(date),
<tt><span style='font-size:10.0pt'>account</span></tt><i> </i>(string) and <tt><span
style='font-size:10.0pt'>amount</span></tt><i> </i>(currency). To slow it down
a bit, it’s indexed uniquely on <tt><span style='font-size:10.0pt'>tranid</span></tt><i>
</i>and indexed with duplicates allowed on <tt><span style='font-size:10.0pt'>trandate</span></tt><i>
</i>and <tt><span style='font-size:10.0pt'>account</span></tt>. Thus any insertion
involves updating three indexes. We created instances of this database in our
sample Access database and in Sybase SQL Anywhere. It starts off empty. The
tests were run on a Pentium 266, with client and server on the same machine and
no other activity taking place. The source code for the test is in the module <i>fastinsert.py</i>
at <a href="http://starship.python.net/crew/mhammond/ppw32/" target="_blank">http://starship.python.net/crew/mhammond/ppw32/</a>.</p>

<p>We first used <tt><span style='font-size:10.0pt'>mxODBC</span></tt> to
connect to both the Access and Sybase databases and tried three different
techniques, which are called Slow, Faster, and Fastest in <a
href="#_Table_13.1._Example_Database_Insert">Table 13.1</a>.</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="100%"
 style='width:100.0%'>
 <tr>
  <td colspan=3 style='border:none;padding:.75pt .75pt .75pt .75pt'>
  <h5 align=center style='text-align:center'><a
  name="_Table_13.1._Example_Database_Insert"></a>Table&nbsp;13.1. Example
  Database Insertion Speeds</h5>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><b><span style='font-size:10.0pt'>Database</span></b></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><b><span style='font-size:10.0pt'>Technique</span></b></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><b><span style='font-size:10.0pt'>Speed</span></b></p>
  <p align=center style='text-align:center'><b><span style='font-size:10.0pt'>(rows/second)</span></b></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Access via </span><tt><span
  style='font-size:10.0pt'>mxODBC</span></tt></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Slow</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>136</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Faster</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>121</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Fastest</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>152</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Sybase via </span><tt><span
  style='font-size:10.0pt'>mxODBC</span></tt></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Slow</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>292</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Faster</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>455</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Fastest</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>523</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Access via JET</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>Raw SQL INSERT</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>108</span></p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>AddNew/Update</span></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p><span style='font-size:10.0pt'>192</span></p>
  </td>
 </tr>
</table>

<p>First, a list of tuples was prepared holding the data for the 1,000 rows. In
the Slow technique, we built a literal SQL statement each time. In the Faster
technique, we used prepared statements as follows:</p>

<pre>mystatement = &quot;&quot;&quot;INSERT INTO analysis (tranid, trandate, account, </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amount) VALUES(?, ?, ?, ?)&quot;&quot;&quot;</pre><pre>for row in mydata:</pre><pre>&nbsp;&nbsp;&nbsp; mycursor.execute(mystatement, row)</pre>

<p>In the technique called Fastest, we used the <tt><span style='font-size:
10.0pt'>executemany()</span></tt> method. This is the same at the database end,
but moves the loop over 1,000 records from interpreted Python code into
compiled C code.</p>

<p>Finally, we connected to the same Access database using the Jet engine. The
two techniques here were to build and execute <tt><span style='font-size:10.0pt'>INSERT</span></tt>
statements directly or to use the <tt><span style='font-size:10.0pt'>AddNew()</span></tt>
and <tt><span style='font-size:10.0pt'>Update()</span></tt> methods of the <tt><span
style='font-size:10.0pt'>RecordSet</span></tt> object.</p>

<p>These results are highly instructive. Sybase is far and away the faster
system, even on a local PC. Also, as theory suggests, using prepared statements
brought about a speedup of 55%, while using <tt><span style='font-size:10.0pt'>executemany()</span></tt>
to optimize out the loop gets us up to over 500 rows per second.</p>

<p>Access, however, shows no improvement at all; in fact, it actually gets
slightly slower! The reason for this is that the Jet engine doesn’t support
prepared statements at all. The Access ODBC drivers do support them for
compatibility purposes, but they presumably get converted back into separate
calls in the driver. The final technique we tried with Access, using <tt><span
style='font-size:10.0pt'>Recordset.AddNew()</span></tt>, was the fastest way to
work with Access databases.</p>

<p>The moral of this story is simple: if you are building a client/server
system in Python, or even prototyping a system in Access that might later be
moved to client/server, use ODBC and parameterize your SQL statements. If you
are building a (hopefully single-user) Access-based system that will never be
moved to client/server, go with DAO or ADO.</p>

<h3><a name="_13.5_Gadfly,_the_Pure_Python_Relati"></a>13.5 Gadfly, the Pure
Python Relational Database</h3>

<p>We now step away from Microsoft APIs altogether. Gadfly is an SQL relational
database written in Python by Aaron Watters. It can be found at <a
href="http://www.chordate.com" target="_blank">http://www.chordate.com</a>, and
is distributed in a 200-KB Zip file, including documentation.</p>

<p>Gadfly gives Python programs relational database capabilities without
relying on any external database engines. It offers the following features:</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Compliance with the Python Database API</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Total portability between platforms</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>A transaction log and recovery procedure</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>A built-in TCP/IP server mode, allowing it to serve clients on remote
machines</p>

<p style='margin-left:.5in;text-indent:-.25in'><span style='font-size:10.0pt;
font-family:Symbol'>·</span><span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Security policies to prevent accidental deletion of data</p>

<p>It’s not intended as a multiuser production system, and some features are
missing at present, notably Null values and Date/Time variables.</p>

<p>Aaron previously produced both a parsing engine named <tt><span
style='font-size:10.0pt'>kwParsing</span></tt> and a library of data
structures, including sets, directed graphs, and dictionaries, called <tt><span
style='font-size:10.0pt'>kjBuckets</span></tt> . These C extensions are part of
the Gadfly package and can build an efficient and fast in-memory SQL engine. If
you are interested in either how to parse SQL statements or in the low-level
relational operations, Gadfly is a great package to explore. To install and set
up Gadfly, perform these steps:</p>

<p style='margin-left:.5in;text-indent:-.25in'>1.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Download the 217-KB Zip file.</p>

<p style='margin-left:.5in;text-indent:-.25in'>2.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Unzip to a directory on the Python path.</p>

<p style='margin-left:.5in;text-indent:-.25in'>3.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>CD to the directory in a DOS prompt.</p>

<p style='margin-left:.5in;text-indent:-.25in'>4.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Type <tt><span style='font-size:10.0pt'>python</span></tt> <tt><span
style='font-size:10.0pt'>gfinstall.py</span></tt>.</p>

<p style='margin-left:.5in;text-indent:-.25in'>5.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Create a subdirectory for a test database with <tt><span
style='font-size:10.0pt'>MKDIR dbtest</span></tt>.</p>

<p style='margin-left:.5in;text-indent:-.25in'>6.<span style='font-size:7.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Type <tt><span style='font-size:10.0pt'>python</span></tt> <tt><span
style='font-size:10.0pt'>gftest.py</span></tt> <tt><span style='font-size:10.0pt'>dbtest</span></tt>.
This creates test tables in the directory and runs a large number of queries.</p>

<h4>13.5.1 Interactive Use</h4>

<p>Gadfly can be used in almost exactly the same way as other data sources:</p>

<pre>&gt;&gt;&gt; from gadfly import gadfly</pre><pre>&gt;&gt;&gt; connection = gadfly(&quot;test&quot;, &quot;c:\\mydir\\gadfly\\dbtest&quot;)</pre><pre>&gt;&gt;&gt; cursor = connection.cursor()</pre><pre>&gt;&gt;&gt; cursor.execute('SELECT * FROM Frequents')</pre><pre>&gt;&gt;&gt; from pprint import pprint</pre><pre>&gt;&gt;&gt; cursor.description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # only does fieldnames at present</pre><pre>(('PERWEEK', None, None, None, None, None, None), </pre><pre>('BAR', None, None, None, None, None, None), </pre><pre>('DRINKER', None, None, None, None, None, None))</pre><pre>&gt;&gt;&gt; print cursor.pp()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# it can format its own output</pre><pre>PERWEEK | BAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | DRINKER</pre><pre>============================</pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | lolas&nbsp;&nbsp;&nbsp; | adam&nbsp;&nbsp; </pre><pre>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | cheers&nbsp;&nbsp; | woody&nbsp; </pre><pre>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | cheers&nbsp;&nbsp; | sam&nbsp;&nbsp;&nbsp; </pre><pre>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | cheers&nbsp;&nbsp; | norm&nbsp;&nbsp; </pre><pre>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | joes&nbsp;&nbsp;&nbsp;&nbsp; | wilt&nbsp;&nbsp; </pre><pre>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| joes&nbsp;&nbsp;&nbsp;&nbsp; | norm&nbsp;&nbsp; </pre><pre>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | lolas&nbsp;&nbsp;&nbsp; | lola&nbsp;&nbsp; </pre><pre>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | lolas&nbsp;&nbsp;&nbsp; | norm&nbsp;&nbsp; </pre><pre>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | lolas&nbsp;&nbsp;&nbsp; | woody&nbsp; </pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | frankies | pierre </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | pans&nbsp;&nbsp;&nbsp;&nbsp; | peter&nbsp; </pre><pre>&gt;&gt;&gt; data = cursor.fetchall()</pre><pre>&gt;&gt;&gt;</pre>

<p>Like most interactive SQL clients, it can format its own output with the <tt><span
style='font-size:10.0pt'>pp()</span></tt> method. One immediate surprise is the
speed: Gadfly operates entirely in local memory and uses highly refined logic
to produce an extremely fast implementation. We won’t go into how!</p>

<p>Gadfly offers the same ability to prepare statements as <tt><span
style='font-size:10.0pt'>mxODBC</span></tt>; if the same statement is passed in
repeated calls, the cursor parses it only once:</p>

<pre>&gt;&gt;&gt;insertstat = &quot;insert into phonenumbers(name,phone) values (?, ?)&quot;</pre><pre>&gt;&gt;&gt;cursor.execute(insertstat, ('nan', &quot;0356&quot;))</pre><pre>&gt;&gt;&gt;cursor.execute(insertstat, ('bill', &quot;2356&quot;))</pre><pre>&gt;&gt;&gt;cursor.execute(insertstat, ('tom', &quot;4356&quot;))</pre><pre>&gt;&gt;&gt;</pre>

<p>A matrix of values can be passed to <tt><span style='font-size:10.0pt'>execute()</span></tt>
in a single try.</p>

<h4>13.5.2 Introspection</h4>

<p>Like many SQL databases, Gadfly maintains metadata in tables, and you can
query the structure of a Gadfly database:</p>

<pre>&gt;&gt;&gt; cursor = connection.cursor()</pre><pre>&gt;&gt;&gt; cursor.execute('SELECT * FROM __table_names__')</pre><pre>&gt;&gt;&gt; print cursor.pp()</pre><pre>IS_VIEW | TABLE_NAME&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>=========================</pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | EMPTY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NONDRINKERS&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ALLDRINKERS&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | __INDICES__&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | DUAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | LIKES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | FREQUENTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ACCESSES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | WORK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | __TABLE_NAMES__</pre><pre>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | SERVES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | __DATADEFS__&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | __COLUMNS__&nbsp;&nbsp;&nbsp; </pre><pre>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | __INDEXCOLS__&nbsp; </pre><pre>&gt;&gt;&gt;</pre>

<p>Apart from the data tables, you can inspect metatables of tables, indexes,
and columns in this manner.</p>

<h4>13.5.3 Network Use</h4>

<p>Gadfly incorporates a TCP/IP client and server, transforming it into a
proper client/server system. To start the server on the machine we’ve already
tested, run the following command from a DOS prompt:</p>

<pre>C:\MYDIR\gadfly&gt;python gfserve.py 2222 test dbtest admin</pre>

<p>The arguments specify the port, the database name, the database directory,
and the password. The server console should start up and display the message
“waiting for connections.”</p>

<p>The client machine needs only the two files, <i>gfclient.py</i> and <i>gfsocket.py</i>
(as well as Python, of course). At 15 KB, this must be one of the lightest
database clients around. On the client machine, start Python and run the
following commands. If you don’t have a second PC handy, you can run the client
from a second DOS prompt (or PythonWin prompt) on the same machine provided
TCP/IP is properly installed:</p>

<pre>&gt;&gt;&gt; # on client machine</pre><pre>&gt;&gt;&gt; from gfclient import gfclient</pre><pre>&gt;&gt;&gt; # connect with policy, port, password, machine name</pre><pre>&gt;&gt;&gt; conn = gfclient(&quot;admin&quot;,2222, &quot;admin&quot;, &quot;tahoe&quot;)</pre><pre>&gt;&gt;&gt; cursor = conn.cursor()</pre><pre>&gt;&gt;&gt; cursor.execute('SELECT * FROM LIKES')</pre><pre>&gt;&gt;&gt; pprint(cursor.fetchall())</pre><pre>[(2, 'bud', 'adam'),</pre><pre> (1, 'rollingrock', 'wilt'),</pre><pre> (2, 'bud', 'sam'),</pre><pre> (3, 'rollingrock', 'norm'),</pre><pre> (2, 'bud', 'norm'),</pre><pre> (1, 'sierranevada', 'nan'),</pre><pre> (2, 'pabst', 'woody'),</pre><pre> (5, 'mickies', 'lola')]</pre><pre>&gt;&gt;&gt;</pre>

<p>As the queries execute, you should see messages on the server console.</p>

<h4>13.5.4 What's It Good for?</h4>

<p>Gadfly still lacks some features of production databases, but what is there
is reputedly stable and fast. It could be useful for a local client that
gathers data and occasionally downloads from or uploads to a master database
elsewhere. It’s an excellent tool for learning about client/server and
relational concepts at zero cost. However, a major niche we see for it is in
data laundering; you can develop scripts rapidly and save the output to local
Gadfly tables, committing the results to a destination database only when the
system is fully refined and working.</p>

<h3><a name="_13.6_Data_Laundering_with_Python"></a>13.6 Data Laundering with
Python</h3>

<p>We have covered a wide range of database APIs and data sources, and
demonstrated that Python can connect to data from any modern database. Now we
will look at some areas in which Python can do useful things with the data.</p>

<p>The first major area of work is what we call <i>data laundering</i>. This
involves writing programs to acquire data from a source database, reshape it in
some way, and load it into a destination database. One major difference between
database development and general application development is that databases are
live; you can’t just switch them off for a few months. This means that what
would be a simple upgrade for a Windows application becomes a much more complex
process of repeatedly migrating data and running in parallel. Here are some
examples of areas where this type of work is needed:</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Database
upgrades and changes</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>When a database is replaced, the new database
structure is almost always different. The new database needs to be developed
with sample data available, then tested extensively, then run in parallel with
the old one while all the users and client applications are moved across.
Scripts are needed to migrate the data repeatedly (usually daily) from source
to destination, often performing validity checks on the way in.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Connecting
databases</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Businesses often have databases whose areas of
interest overlap. A fund manager might have a core system for processing deals
in its funds, and a marketing database for tracking sales calls; marketing
needs a recent copy of some of the deal information to help serve the clients,
possibly simplified and pre-digested in various ways. Again, a daily process of
exporting, rearranging, and loading is needed.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Data
warehouses</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>The classic case for repeated data laundering is
the data warehouse. A company has one or more transaction-processing databases,
which usually have numerous highly normalized tables, optimized for insertion
and lookups of small numbers of records at any one time. A data warehouse is a
second, parallel database optimized for analysis. It’s essentially read-only
with a simple structure geared to computing averages and totals across the
whole database. This is refreshed daily in a process known as the <i>production
data load</i>. The production data load needs to acquire data from several
databases, reshape it in ways that are often impossible for SQL, validate it in
various ways, then load into the destination database. This is a perfect niche
for Python.</p>

<p>All these tasks involve writing scripts to reshape the data.</p>

<p>We’ll now start to build a toolkit to help with these kinds of operations.
The toolkit is based on real classes and functions that have been used in a
number of serious projects and have proved their utility many times over (see
the case study later on), although we have simplified and cut down the code considerably
for this book. All the code for the rest of this chapter can be found in the
module <i>laundry.py</i> at <a
href="http://starship.python.net/crew/mhammond/ppw32/" target="_blank">http://starship.python.net/crew/mhammond/ppw32/</a>.</p>

<h4>13.6.1 Data as Rows</h4>

<p>There are several useful ways to represent data. The most obvious is as
rows. The Python format for data as rows returned from database cursors is a
list of tuples.</p>

<p>This is such a common representation that we’ll wrap it in a class called <tt><span
style='font-size:10.0pt'>DataSet</span></tt> . The class doesn’t serve to hide
the data; it’s just a convenient place to hang a load of data-manipulation
methods (as well as to keep the field names). Here’s part of its definition,
showing how to construct a <tt><span style='font-size:10.0pt'>DataSet</span></tt>
and display its contents:</p>

<pre>class DataSet:</pre><pre>&nbsp;&nbsp;&nbsp; &quot;wrapper around a tabular set of data&quot;</pre><pre>&nbsp;&nbsp;&nbsp; def __init__(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.data = []</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.fieldnames = []</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;def pp(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Pretty-print a row at a time - nicked from Gadfly&quot;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from string import join</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stuff = [repr(self.fieldnames)] + map(repr, self.data)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print join(stuff, &quot;\n&quot;)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>def DataSetFromCursor(cursor):</pre><pre>&nbsp;&nbsp;&nbsp; &quot; a handy constructor&quot;</pre><pre>&nbsp;&nbsp;&nbsp; ds = DataSet()</pre><pre>&nbsp;&nbsp;&nbsp; ds.fieldnames = getFieldNames(cursor)</pre><pre>&nbsp;&nbsp;&nbsp; ds.data = cursor.fetchall()</pre><pre>&nbsp;&nbsp;&nbsp; return ds</pre>

<p>You can use this as follows:</p>

<pre>&gt;&gt;&gt; import ODBC.Windows</pre><pre>&gt;&gt;&gt; conn = ODBC.Windows.Connect('PYDBDEMOS')</pre><pre>&gt;&gt;&gt; cursor = conn.cursor()</pre><pre>&gt;&gt;&gt; cursor.execute('SELECT ClientID, PeriodEnding, Consultant, </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;Hours FROM Invoices')</pre><pre>&gt;&gt;&gt; import laundry</pre><pre>&gt;&gt;&gt; ds = laundry.DataSetFromCursor(cursor)</pre><pre>&gt;&gt;&gt; cursor.close()</pre><pre>&gt;&gt;&gt; conn.close()</pre><pre>&gt;&gt;&gt; ds.pp()</pre><pre>('ClientID', 'PeriodEnding', 'Consultant', 'Hours')</pre><pre>('MEGAWAD', 1999-04-18 00:00:00.00, 'Joe Hacker', 42.0)</pre><pre>('MEGAWAD', 1999-04-18 00:00:00.00, 'Arthur Suit', 24.0)</pre><pre>('MEGAWAD', 1999-04-25 00:00:00.00, 'Joe Hacker', 57.0)</pre><pre>('NOSHCO', 1999-04-25 00:00:00.00, 'Tim Trainee', 18.0)</pre><pre>('MEGAWAD', 1999-04-18 00:00:00.00, 'Joe Hacker', 42.0)</pre><pre>&gt;&gt;&gt;</pre>

<p>The ability to see the field names becomes useful when writing data-cleaning
scripts at an interactive prompt.</p>

<h4>13.6.2 Geometric Operations</h4>

<p>Now that we have the data, what to do with it depends on the operation
taking place. An approach that has stood the test of time is to keep adding
operations to the <tt><span style='font-size:10.0pt'>Dataset</span></tt> class,
building over time a veritable Swiss army knife. Common families of operations
can include:</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Field
transformations</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Applying functions to entire columns in order to
format numbers and dates, switch encodings, or build database keys.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Row and
column operations</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Inserting, appending, and deleting whole columns,
breaking into several separate datasets whenever a certain field changes, and
sorting operations.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Filter
operations</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Extracting or dropping rows meeting user-defined
criteria.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Geometric
operations</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Cross-tabulate, detabulate (see <a
href="#_Figure_13.4._Detabulating_and_addin">Figure 13.4</a>), and transpose.</p>

<p class=MsoNormal><i><span style='font-family:Arial;color:#990000'>Storage
operations</span></i><span style='font-family:Arial'> </span></p>

<p style='margin-left:.5in'>Load and save to native Python data (<tt><span
style='font-size:10.0pt'>marshal</span></tt>, <tt><span style='font-size:10.0pt'>cPickle</span></tt>),
delimited text files, and fixed-width text files.</p>

<p>Some of these operations are best understood diagrammatically. Consider the
operation in <a
href="http://safari.oreilly.com/main.asp?bookname=pythonwin32&amp;snode=108#5">Figure
13.4</a>, which can’t be performed by SQL.</p>

<h5 align=center style='text-align:center'><a
name="_Figure_13.4._Detabulating_and_addin"></a>Figure 13.4. Detabulating and
adding constant columns</h5>

<p class=MsoNormal align=center style='text-align:center'><span
style='font-family:Arial'><img border=0 width=502 height=198
src="images\image054.gif" alt="figs/ppw.1304.gif"></span></p>

<p>This operation was a mainstay of the case study that follows. Once the
correct operations have been created, it can be reduced to a piece of Python code:</p>

<pre>&gt;&gt;&gt; ds1.pp()&nbsp;&nbsp; # presume we have the table above already</pre><pre>('Patient', 'X', 'Y', 'Z')</pre><pre>('Patient 1', 0.55, 0.08, 0.97)</pre><pre>('Patient 2', 0.54, 0.11, 0.07)</pre><pre>('Patient 3', 0.61, 0.08, 0.44)</pre><pre>('Patient 4', 0.19, 0.46, 0.41)</pre><pre>&gt;&gt;&gt; ds2 = ds1.detabulate()</pre><pre>&gt;&gt;&gt; ds2.addConstantColumn('Date',DateTime(1999,5,1),1)</pre><pre>&gt;&gt;&gt; ds2.addConstantColumn('Lab','QMH', 1)</pre><pre>&gt;&gt;&gt; ds2.pp()</pre><pre>('Row', 'Lab', 'Date', 'Column', 'Value')</pre><pre>('Patient 1', 'QMH', 1999-05-01 00:00:00.00, 'X', 0.55)</pre><pre>('Patient 2', 'QMH', 1999-05-01 00:00:00.00, 'X', 0.54)</pre><pre>('Patient 3', 'QMH', 1999-05-01 00:00:00.00, 'X', 0.61)</pre><pre>('Patient 4', 'QMH', 1999-05-01 00:00:00.00, 'X', 0.19)</pre><pre>('Patient 1', 'QMH', 1999-05-01 00:00:00.00, 'Y', 0.08)</pre><pre>('Patient 2', 'QMH', 1999-05-01 00:00:00.00, 'Y', 0.11)</pre><pre>('Patient 3', 'QMH', 1999-05-01 00:00:00.00, 'Y', 0.08)</pre><pre>('Patient 4', 'QMH', 1999-05-01 00:00:00.00, 'Y', 0.46)</pre><pre>('Patient 1', 'QMH', 1999-05-01 00:00:00.00, 'Z', 0.97)</pre><pre>('Patient 2', 'QMH', 1999-05-01 00:00:00.00, 'Z', 0.07)</pre><pre>('Patient 3', 'QMH', 1999-05-01 00:00:00.00, 'Z', 0.44)</pre><pre>('Patient 4', 'QMH', 1999-05-01 00:00:00.00, 'Z', 0.41)</pre><pre>&gt;&gt;&gt;</pre>

<p>We won’t show the methods to implement this; they involve straightforward
Python loops and list slicing, as do most of the things we would want to do
with a <tt><span style='font-size:10.0pt'>DataSet</span></tt>. Their effect is
to take our data-laundering scripts to a higher level of abstraction and
clarity.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%'>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <h3 align=center style='text-align:center'>Case Study: Applied Biometrics</h3>
  <p>Applied Biometrics, GmbH, in Berlin provides statistics and data quality
  assurance for medical studies. The company is run by Chris Tismer, the initiator
  and administrator of the Python Starship ( <a
  href="http://starship.python.net)" target="_blank">http://starship.python.net)</a>,
  a web site that provides home pages to many of the most interesting Python
  extensions.</p>
  <p>When drugs are being tested, case report forms are prepared on each
  patient in the study with literally hundreds of measurements of all kinds.
  Data needs to be keyboarded twice, normalized somehow, and analyzed, with the
  final result being a 100+ page report summarizing the data. Applied
  Biometrics automates the whole process with Python and Office, Access
  databases are built for each study, and the analysis and reporting are
  handled by Python scripts. The data never arrives all at once, so the whole
  process must be automated and repeatable.</p>
  <p>In 1997, Applied Biometrics took on a challenge no other rival would
  touch: try to combine everything known about a certain drug into one
  comprehensive database. Studies ranged from controlled short-term lab tests
  (few patients, same things measured on each) to badly kept patient diaries
  from thousands of patients. Data sources also varied from AB’s own keyboarded
  data to tables from statistical packages and even text files to be parsed.
  Andy Robinson helped to formulate an overall approach in the early stages.</p>
  <p>It was necessary to find an approach that allowed medical and statistics
  graduates with little programming experience to write data-laundering
  scripts. We came up with the concept of a data warehouse of very general
  measurements (of a variable, on a patient, at a point in time). The <i>Dataset</i>
  concept was developed, and we wrote methods to provide common geometric
  operations—slicing and dicing by column or row, transposing, grouping, and
  detabulating. The students were able to understand these basic operations and
  write scripts to launder individual databases. The end product was a stream
  of measurements that went through a verification funnel before entering a
  target database.</p>
  <p>Chris has been optimizing this system for two years, and knows more about controlling
  Word and Access from Python than anyone. The current system builds a database
  of 315,000 measurements from 29 different source databases in 50 minutes.</p>
  </td>
 </tr>
</table>

</div>

<h4>13.6.3 Data as Dictionaries</h4>

<p>Another useful and powerful representation of data is as a dictionary of
keys and values. This leads to a much easier syntax when you edit and modify
records; the field names can be used rather than numeric indexes. It’s also
useful when putting together data about the same thing from different sources.
There will be some overlap between fields, but not total agreement.
Dictionaries can represent sparse data compactly. A classic example is found in
the <tt><span style='font-size:10.0pt'>Transaction</span></tt> architecture
from <a href="8.htm#_Part_II:_Building_an_Advanced_Pytho">Part II</a>, where
there was a method to convert a transaction to a list of dictionaries. A sales
transaction has different keys and values from a payroll transaction.</p>

<p>You’ll rarely want just one dictionary, so we have added the following
method to convert a <tt><span style='font-size:10.0pt'>DataSet</span></tt> to a
list of dictionaries:</p>

<pre>class DataSet:</pre><pre>&nbsp;&nbsp;&nbsp; &lt;continued...&gt;</pre><pre>&nbsp;&nbsp;&nbsp; def asDicts(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;returns a list of dictionaries, each with all fieldnames&quot;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dicts = []</pre><pre>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fieldcount = len(self.fieldnames)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for row in self.data:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict = {}</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in range(fieldcount):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict[self.fieldnames[i]] = row[i]</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dicts.append(dict)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dicts</pre>

<p>This enables you to get a row from a query and modify it flexibly: let’s
grab our first invoice from the sample database and look at it. Assume you’ve
just done a <tt><span style='font-size:10.0pt'>'Select</span></tt> <tt><span
style='font-size:10.0pt'>*</span></tt> <tt><span style='font-size:10.0pt'>FROM</span></tt>
<tt><span style='font-size:10.0pt'>Invoices'</span></tt> in a cursor:</p>

<pre>&gt;&gt;&gt; dict = ds.asDicts()[0]&nbsp;&nbsp; # grab the first one</pre><pre>&gt;&gt;&gt; pprint(dict)</pre><pre>{'ClientID': 'MEGAWAD',</pre><pre> 'Comments': None,</pre><pre> 'Consultant': 'Joe Hacker',</pre><pre> 'DatePaid': None,</pre><pre> 'ExpenseDetails': None,</pre><pre> 'Expenses': 0.0,</pre><pre> 'HourlyRate': 50.0,</pre><pre> 'Hours': 42.0,</pre><pre> 'InvoiceDate': 1999-04-15 00:00:00.00,</pre><pre> 'InvoiceID': 199904001,</pre><pre> 'PeriodEnding': 1999-04-18 00:00:00.00,</pre><pre> 'TaxRate': 0.175}</pre><pre>&gt;&gt;&gt;</pre>

<p>You can now modify this easily, overwriting, dropping, and adding keys as
needed. It’s also possible to build powerful relational joins in a few lines of
code using Python dictionaries; that is part of what Gadfly does.</p>

<p>When you want to do the opposite, tabulate a list of dictionaries easily by
specifying the keys you want. The next function creates dictionaries:</p>

<pre>def DataSetFromDicts(dictlist, keylist=None):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # tabulates shared keys</pre><pre>&nbsp;&nbsp;&nbsp; if not keylist:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # take all the keys</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all_key_dict = dictlist[0]</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dict in dictlist:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all_key_dict.update(dict)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keylist = all_key_dict.keys()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keylist.sort()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # better than random order</pre><pre>&nbsp;&nbsp;&nbsp; ds = DataSet()</pre><pre>&nbsp;&nbsp;&nbsp; ds.fieldnames = tuple(keylist)</pre><pre>&nbsp;&nbsp;&nbsp; for dict in dictlist:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # loop over rows</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row = []&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for key in keylist:&nbsp;&nbsp;&nbsp;&nbsp; # loop over fields</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = dict[key]</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = None</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row.append(value)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ds.data.append(tuple(row))</pre><pre>&nbsp;&nbsp;&nbsp; return ds</pre>

<p>If you supply a list of the keys you want, this function builds a <tt><span
style='font-size:10.0pt'>Dataset</span></tt> with columns to match; if you omit
the keys, it shows the set of all keys found in all dictionaries. This can be
used as follows:</p>

<pre>&gt;&gt;&gt; pc1 = {'Name':'Yosemite', 'Maker':'Carrera','Speed':266}</pre><pre>&gt;&gt;&gt; pc2 = {'Name':'Tahoe', 'Maker':'Gateway','Memory':64}</pre><pre>&gt;&gt;&gt; pc3 = {'Name':'Gogarth','Maker':'NeXT','Speed':25,'Elegance':'Awesome'}</pre><pre>&gt;&gt;&gt; pc4 = {'Name':'BoxHill','Maker':'Psion','Memory':2}</pre><pre>&gt;&gt;&gt; my_kit = [pc1,pc2,pc3,pc4]</pre><pre>&gt;&gt;&gt; comparison = laundry.DataSetFromDicts(my_kit, </pre><pre>... &nbsp;&nbsp;&nbsp; ['Name','Model','Memory']</pre><pre>... &nbsp;&nbsp;&nbsp; )</pre><pre>... &nbsp;&nbsp;&nbsp; </pre><pre>&gt;&gt;&gt; comparison.pp()</pre><pre>('Name', 'Model', 'Memory')</pre><pre>('BoxHill', None, 2)</pre><pre>('Tahoe', None, 64)</pre><pre>('Gogarth', None, None)</pre><pre>('BoxHill', None, 2)</pre><pre>&gt;&gt;&gt;</pre>

<p>You now have the ability to move back and forth from a tabular to a
dictionary representation.</p>

<h4>13.6.4 Inserting Data into the Destination Database</h4>

<p>Sooner or later you need to pump data into a destination database. We’ve
already seen how DBAPI-compliant modules allow us to insert a list of tuples at
one time, and how this provides optimal performance. In a case such as a data
warehouse, the number of destination tables and fields will be quite small so
it’s no trouble to build the SQL statements by hand for each table; and we
already have the list of tuples ready to go:</p>

<pre>mycursor.executemany(MyTableStatement, MyDataSet.data)</pre>

<p>Where there are many destination tables, a shortcut can be taken if the
field names are simple and match the underlying database well; you can write a
routine that uses the field names in the <tt><span style='font-size:10.0pt'>DataSet</span></tt>
and generates an SQL <tt><span style='font-size:10.0pt'>INSERT</span></tt>
statement to match.</p>

<p>Often there are better ways to bulk-load data. The important thing is to
know that you have correctly structured <tt><span style='font-size:10.0pt'>DataSets</span></tt>
for the destination database; if that’s true, you can often save them to a tab-
or comma-delimited file and use the database’s bulk-load facility with far
greater speed.</p>

<h3><a name="_13.7_A_Three-Tier_Architecture_with"></a>13.7 A Three-Tier
Architecture with Business Objects</h3>

<p>For our final example of what Python can do with data, we’ll look at how
Python supports building a three-tier client/server architecture. This will be
a fairly straightforward example, as we did a lot of the groundwork in the last
section.</p>

<p>Simple database applications have two tiers: database and user interface. A
dialog to maintain client details might perform a <tt><span style='font-size:
10.0pt'>SELECT</span></tt> query to get all the details of a customer and store
those details in the user interface; either directly in text boxes, or in
variables stored in the same form or module. When the data has been changed,
the system performs an <tt><span style='font-size:10.0pt'>UPDATE</span></tt>
query to store the results.</p>

<p>A three-tier architecture creates a <tt><span style='font-size:10.0pt'>Customer</span></tt>
class to hold the information, and provides functions to load customers from
the database and store them back to it. The GUI layer gets data from the <tt><span
style='font-size:10.0pt'>Customer</span></tt> objects. Objects in the middle
layer are often known as <i>business objects</i> , because they model things in
the business or problem domain, rather than systems objects like database
connections, or GUI objects like queries. If you are writing object-oriented
programs, you’re already at work on the business objects.</p>

<p>Three-tier also describes network partitioning. With modern
distributed-object technologies such as COM and CORBA (and some much lighter
alternatives like Python’s <tt><span style='font-size:10.0pt'>RemoteCall</span></tt>
package), it’s easy to run the database on one machine, the business objects on
another, and the GUI on a third. It’s highly likely that your <tt><span
style='font-size:10.0pt'>Customer</span></tt> object will pop up in many parts
of the application, so the three-tier approach is much better for all but the
simplest application. There’s a lot of marketing hype about this. We’ll just
focus on the logical aspects.</p>

<p>Real-life databases need lots of tables to represent a business object such
as a customer or an invoice. Similarly, the objects in memory are bound to have
references to other objects and lists of subobjects; a <tt><span
style='font-size:10.0pt'>Customer</span></tt> object may provide access to a
list of invoices, and a list of correspondence items received. There is a lot
of work involved in building class hierarchies and tables to match each other and
code to fetch and store the right records at the right time. Furthermore, every
change in the database may necessitate changing and recompiling your business
object code, and vice versa.</p>

<p>Not with Python! Python’s dynamic nature makes it possible to dramatically
reduce the dependencies between database and business objects.</p>

<h4>13.7.1 Dynamic Attributes</h4>

<p>We saw in <a href="9.htm#_Chapter_6._A_Financial_Modeling_Too">Chapter 6</a><i>,</i>
that Python objects can hold any attributes you want, in addition to those
defined for the class. Any Python object’s attributes and methods are held in a
hidden, internal dictionary. And we have just learned how to fetch those!</p>

<p>The simplest way to construct an object from a database is to use an
almost-empty class. Remember you can add attributes at runtime to a Python
class as follows:</p>

<pre>&gt;&gt;&gt; class DumbDbRecord:</pre><pre>...&nbsp;&nbsp;&nbsp;&nbsp; pass</pre><pre>... </pre><pre>&gt;&gt;&gt; r1 = DumbDbRecord()</pre><pre>&gt;&gt;&gt; r1.CustomerID = 1234</pre><pre>&gt;&gt;&gt; r1.Name = 'Pythonics Inc.'</pre><pre>&gt;&gt;&gt;</pre>

<p>It would be easy to examine a database cursor and add all attributes to an
object such as this, creating a handy database record object with a clean
syntax. However, this approach carries a weakness. You presumably will want to
write objects that have attributes and methods important to the functioning of
the program, and to keep them separate from data fetched from the database.
We’ve therefore defined a class that can accept a dictionary of fields and
values and keep them separate from its own attributes.</p>

<p>A helpful piece of Python magic is the ability to trap attribute access. We
saw in <a href="9.htm#_Chapter_6._A_Financial_Modeling_Too">Chapter 6</a> that
a Python object can monitor attempts to set or get its attributes. If you ask
an instance of this next class for an attribute it can’t find, it goes and
checks in the dictionary it got from the database:</p>

<pre>class Record:</pre><pre>&nbsp;&nbsp;&nbsp; #holds arbitrary database data</pre><pre>&nbsp;&nbsp;&nbsp; def __init__(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._dbdata = {}</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;def loadFromDict(self, aDict):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;accept all attributes in the dictionary&quot;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._dbdata.update(aDict)</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp; def getData(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self._dbdata.copy()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;def pp(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;pretty-print my database data&quot;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pprint(self._dbdata)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;def __getattr__(self, key):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;&quot;&quot;This is called if the object lacks the attribute.</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the key is not found, it raises an error in the</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same way that the attribute access would were no</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __getattr__ method present.&nbsp; &quot;&quot;&quot;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self._dbdata[key]</pre>

<p>Now you can use it to represent any kind of object you want and access the
variables with the most natural syntax:</p>

<pre>&gt;&gt;&gt; import laundry</pre><pre>&gt;&gt;&gt; pc_dict = {'Name':'Yosemite', 'Maker':'Carrera','Speed':266}</pre><pre>&gt;&gt;&gt; rec = laundry.Record()</pre><pre>&gt;&gt;&gt; rec.loadFromDict(pc_dict)</pre><pre>&gt;&gt;&gt; rec.Maker</pre><pre>'Carrera'</pre><pre>&gt;&gt;&gt; rec.Speed</pre><pre>266</pre><pre>&gt;&gt;&gt;</pre>

<p>It’s easy to extend <tt><span style='font-size:10.0pt'>DataSet</span></tt>
to get a list of objects rather than dictionaries, and your data-manipulation
code will be extremely readable. Furthermore, you can derive many of the <tt><span
style='font-size:10.0pt'>INSERT</span></tt> and <tt><span style='font-size:
10.0pt'>UPDATE</span></tt> statements you need automatically.</p>

<p>If you use this class and populate it with the results of a query, whenever
someone adds a database field to the Customers table, your objects acquire the
new data attribute automatically. If someone deletes a database field the
program needs, your code will need fixing (Python is powerful, but not
telepathic) but your model can be made reasonably robust against the deletion
on information fields as well.<a name="_ftnref15"></a><a href="#_ftn15"><span
class=atitlechar><sup><span style='font-size:9.0pt'>[7]</span></sup></span></a></p>

<h4>13.7.2 Lazy Fetches</h4>

<p>The examples in this chapter used two tables, one of clients and one of
invoices, with a master-detail relationship. In terms of objects, you’d say
that a client has a list of related invoices. However, it might be expensive to
fetch these every time when a user might want to see them only some of the
time.</p>

<p>Let’s implement a <i>lazy fetch</i> to get the data on demand. This <tt><span
style='font-size:10.0pt'>Customer</span></tt> class inherits from our <tt><span
style='font-size:10.0pt'>Record</span></tt> class. Given a database connection,
it fetches its main attributes when explicitly asked, but the invoice list is
retrieved on demand:</p>

<pre>class Customer(Record):</pre><pre>&nbsp;&nbsp;&nbsp; def __getattr__(self, key):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #trap attempts to fetch the list of invoices</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if key == 'Invoices':</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.fetchInvoices()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.Invoices</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #call the inherited method</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Record.__getattr__(self, key)</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp; def fetch(self, conn, key):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.conn = conn</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor = self.conn.cursor()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(&quot;SELECT * FROM Clients \</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE ClientID = '%s'&quot; % key)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dicts = DataSetFromCursor(cursor).asDicts()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert len(dicts) == 1, 'Error fetching data!'</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.loadFromDict(dicts[0])</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;def fetchInvoices(self):</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #presumes an attribute pointing to the database</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor = self.conn.cursor()</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(&quot;SELECT * FROM Invoices \ </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE ClientID = '%s'&quot; % self.ClientID)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ds = DataSetFromCursor(cursor)</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.Invoices = ds.asObjects()</pre>

<p>Using this class is straightforward:</p>

<pre>&gt;&gt;&gt; c = laundry.Customer()</pre><pre>&gt;&gt;&gt; c.fetch(conn, 'MEGAWAD')&nbsp;&nbsp; # assume an open connection</pre><pre>&gt;&gt;&gt; c.CompanyName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # see if we got data...</pre><pre>'MegaWad Investments'</pre><pre>&gt;&gt;&gt; c.pp()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # let's see all the fields</pre><pre>{'Address1': '1 St. Fredericks-Le-Grand',</pre><pre> 'Address2': 'London EC1A 8AB',</pre><pre> 'Address3': None,</pre><pre> 'Address4': None,</pre><pre> 'ClientID': 'MEGAWAD',</pre><pre> 'CompanyName': 'MegaWad Investments',</pre><pre> 'ContactName': 'Hachiro Kobayashi'}</pre><pre>&gt;&gt;&gt; len(c.Invoices)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # trigger another fetch</pre><pre>4</pre><pre>&gt;&gt;&gt; c.Invoices[0].Hours&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # access a child object </pre><pre>42.0</pre><pre>&gt;&gt;&gt;</pre>

<p>The example so far only fetches data. The <tt><span style='font-size:10.0pt'>__setattr_
_()</span></tt> method lets you trap attempts to set attributes in an analogous
way, which you can use to update field lists, type-check arguments, and keep
track of whether an object has changed and so needs updates posted back to the
database.</p>

<p>It’s possible in Python to build an even more general data-driven object
framework, where you declared some mapping of objects to database rows, along
with the names of classes to use and the relationships between database tables,
and let Python build an entire web of objects on demand. </p>

<h3><a name="_13.8_Conclusion"></a>13.8 Conclusion</h3>

<p>The various integration technologies in Python make it easy to acquire data
from any database. ODBC is our favorite because it turns the data into Python
variables with the greatest speed and least lines of code; however, we have
shown you how to get connected with a wide range of tools.</p>

<p>Once you fetch the data, manipulating it is easy in Python. Python objects
can hold numbers, strings, and dates; and sets of data can be represented in
native Python lists and tuples. This means the data is right there in front of
you; there’s no need to loop over the properties of <tt><span style='font-size:
10.0pt'>Recordset</span></tt> objects or cursors.</p>

<p>In this chapter, we have shown how to build the beginnings of a powerful
toolkit for transforming and manipulating data in Python. This makes it easy to
switch between different representations of data, as rows, dictionaries of keys
and values, or objects.</p>

<p>Python is particularly well suited to writing data-laundering scripts and to
constructing dynamic object models on top of a database.</p>

<h3><a name="_13.9_References"></a>13.9 References</h3>

<p>There is a Python Database Topic Guide at <a
href="http://www.python.org/topics/database/" target="_blank">http://www.python.org/topics/database/</a>
with many useful pointers.</p>

<p><tt><span style='font-size:10.0pt'>mxODBC</span></tt> lives at <a
href="http://starship.python.net/crew/lemburg/mxODBC.html" target="_blank">http://starship.python.net/crew/lemburg/mxODBC.html</a>.</p>

<p>Gadfly lives at <a href="http://www.chordate.com/gadfly.html" target="_blank">http://www.chordate.com/gadfly.html</a>.</p>

<p>For those interested in ODBC internals and capabilities, SolidTech include a
full ODBC manual with their documentation at <a
href="http://www.solidtech.com/devzone/manuals/" target="_blank">http://www.solidtech.com/devzone/manuals/</a>.</p>

<p><i>Access Database Design and Programming</i> by Steven Roman (O’Reilly)
provides an excellent introduction to relational database concepts, SQL, and
the formal operations on which it’s built. It also provides a complete
reference to Microsoft Access SQL (including the Data Definition Language) and
to the DAO object hierarchy.</p>

<p><i>The Data Warehouse Toolkit </i>by Ralph Kimball (John Wiley &amp; Sons)
is the definitive text on its subject and an excellent introduction to what
goes on in real-world database projects.</p>

<p class=MsoFootnoteText><a name="_ftn9"></a><a
href="17.htm#_ftnref9" title=""><span
class=MsoFootnoteReference>[1]</span></a> <span style='font-size:7.5pt'>Formally
speaking, it implements the ANSI SQL Part III specification for a Call Level
Interface to relational databases. In other words, it’s not just Microsoft;
it’s an approved ANSI standard.</span></p>

<p class=MsoFootnoteText><a name="_ftn10"></a><a
href="17.htm#_ftnref10" title=""><span
class=MsoFootnoteReference>[2]</span></a> <span style='font-size:7.5pt'>The
Data Control allows you to build a database form by setting a few properties
and linking text boxes to database fields. It queries the database at runtime
about the kinds of fields available in the tables to which it’s bound; this
works fine with Jet, which has the information readily available, but generates
unbelievable traffic over a client/server connection. We’ve watched it by
logging ODBC calls, and each data control makes a separate connection; one
application might have 10 or 12 database connections open.</span></p>

<p class=MsoFootnoteText><a name="_ftn11"></a><a
href="17.htm#_ftnref11" title=""><span
class=MsoFootnoteReference>[3]</span></a> <span style='font-size:7.5pt'>This is
the system used in COM dates as seen in <a href="12.htm">Chapter 9</a>.</span></p>

<p class=MsoFootnoteText><a name="_ftn12"></a><a
href="17.htm#_ftnref12" title=""><span
class=MsoFootnoteReference>[4]</span></a> <span style='font-size:7.5pt'>Microsoft
is committed to extending ODBC as needed to comply with developments such as
SQL3, without breaking existing code.</span></p>

<p class=MsoFootnoteText><a name="_ftn13"></a><a
href="17.htm#_ftnref13" title=""><span
class=MsoFootnoteReference>[5]</span></a> <span style='font-size:7.5pt'>There
are plans to merge the two into one package in the near future. At the time of
this writing, the current versions are 1.1.1 for </span><tt>mxODBC</tt><span
style='font-size:7.5pt'> and 1.3.0 for </span><tt>mxDateTime</tt><span
style='font-size:7.5pt'>.</span></p>

<p class=MsoFootnoteText><a name="_ftn14"></a><a
href="17.htm#_ftnref14" title=""><span
class=MsoFootnoteReference>[6]</span></a> <tt>executemany()</tt><span
style='font-size:7.5pt'> is the new standard, but many interface modules
(including </span><tt>mxODBC</tt><span style='font-size:7.5pt'> and Gadfly)
allow you to pass a list of tuples to </span><tt>execute()</tt><span
style='font-size:7.5pt'> as well.</span></p>

<p class=MsoFootnoteText><a name="_ftn15"></a><a
href="17.htm#_ftnref15" title=""><span
class=MsoFootnoteReference>[7]</span></a> <span style='font-size:7.5pt'>Some
Python GUI libraries, such as Tkinter, make it easy to build dialogs
dynamically as well, so that the edit boxes displayed on a customer dialog
could also depend on the available data.</span></p>

<p class=MsoNormal>&nbsp;</p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="90%"
 style='width:90.0%;background:#ECECD9;border-collapse:collapse;border:none'>
 <tr>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><a href="16.htm"><span style='text-decoration:none'><img
  border=0 width=37 height=34 src="leftarrw.gif"></span></a></p>
  </td>
  <td width="33%" style='width:33.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><a href="0.htm"><span
  style='font-size:13.5pt'>Table of Contents</span></a></p>
  </td>
  <td width="34%" style='width:34.0%;border:inset #111111 1.0pt;border-left:
  none;padding:.75pt .75pt .75pt .75pt'>
  <p align=right style='text-align:right'><a href="18.htm"><span
  style='text-decoration:none'><img border=0 width=37 height=34
  src="rightarrw.gif"></span></a></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

</div>

</body>

</html>
